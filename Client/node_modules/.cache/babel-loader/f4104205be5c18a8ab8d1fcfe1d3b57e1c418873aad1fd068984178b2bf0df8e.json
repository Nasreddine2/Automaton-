{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Musha\\\\Desktop\\\\DAAR\\\\projet\\\\projet1\\\\src\\\\app\\\\automate.js\",\n  _s = $RefreshSig$();\nimport React, { useState } from \"react\";\n\n// Compteur d'état global pour assurer des identifiants uniques\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nlet stateCounter = 0;\n\n// Classe Automate pour stocker les états et transitions\nclass Automate {\n  constructor() {\n    this.states = [];\n    this.transitions = [];\n    this.startState = null;\n    this.endState = null;\n  }\n\n  // Fonction pour ajouter un état avec un identifiant unique\n  addState() {\n    const newState = stateCounter++;\n    this.states.push(newState);\n    return newState;\n  }\n  addTransition(from, to, symbol) {\n    this.transitions.push({\n      from,\n      to,\n      symbol\n    });\n  }\n  setStartState(state) {\n    this.startState = state;\n  }\n  setEndState(state) {\n    this.endState = state;\n  }\n  getAutomate() {\n    return {\n      states: this.states,\n      transitions: this.transitions,\n      startState: this.startState,\n      endState: this.endState\n    };\n  }\n}\n\n// Fonction pour créer un automate pour un symbole\nconst createBaseAutomate = symbol => {\n  const automate = new Automate();\n  const start = automate.addState();\n  const end = automate.addState();\n  automate.addTransition(start, end, symbol);\n  automate.setStartState(start);\n  automate.setEndState(end);\n  return automate;\n};\n\n// Fonction pour concaténer deux automates\nconst concatenateAutomates = (automate1, automate2) => {\n  const automate = new Automate();\n\n  // Copier les états et transitions des deux automates\n  automate.states = [...automate1.states, ...automate2.states];\n  automate.transitions = [...automate1.transitions, ...automate2.transitions];\n\n  // Ajouter une transition epsilon entre la fin du premier automate et le début du second\n  automate.addTransition(automate1.endState, automate2.startState, \"ε\");\n\n  // Définir les nouveaux états de départ et de fin\n  automate.setStartState(automate1.startState);\n  automate.setEndState(automate2.endState);\n  return automate;\n};\n\n// Fonction pour gérer l'union de deux automates (opérateur |)\nconst unionAutomates = (automate1, automate2) => {\n  const automate = new Automate();\n  const start = automate.addState(); // Nouvel état de départ\n  const end = automate.addState(); // Nouvel état de fin\n\n  // Copier les états et transitions des deux automates\n  automate.states = [...automate1.states, ...automate2.states, start, end];\n  automate.transitions = [...automate1.transitions, ...automate2.transitions];\n\n  // Ajouter des transitions epsilon du nouvel état initial vers les deux sous-automates\n  automate.addTransition(start, automate1.startState, \"ε\");\n  automate.addTransition(start, automate2.startState, \"ε\");\n\n  // Ajouter des transitions epsilon des états finaux des sous-automates vers le nouvel état final\n  automate.addTransition(automate1.endState, end, \"ε\");\n  automate.addTransition(automate2.endState, end, \"ε\");\n\n  // Définir les nouveaux états de départ et de fin\n  automate.setStartState(start);\n  automate.setEndState(end);\n  return automate;\n};\n\n// Fonction pour gérer la fermeture de Kleene (opérateur *)\nconst kleeneAutomate = automate1 => {\n  const automate = new Automate();\n  const start = automate.addState(); // Nouvel état de départ\n  const end = automate.addState(); // Nouvel état de fin\n\n  // Copier les états et transitions du premier automate\n  automate.states = [...automate1.states, start, end];\n  automate.transitions = [...automate1.transitions];\n\n  // Ajouter des transitions epsilon pour la fermeture de Kleene\n  automate.addTransition(start, automate1.startState, \"ε\");\n  automate.addTransition(automate1.endState, end, \"ε\");\n  automate.addTransition(automate1.endState, automate1.startState, \"ε\"); // Boucle\n  automate.addTransition(start, end, \"ε\"); // Transition directe\n\n  // Définir les nouveaux états de départ et de fin\n  automate.setStartState(start);\n  automate.setEndState(end);\n  return automate;\n};\n\n// Fonction pour gérer l'opérateur +\nconst plusAutomate = automate1 => {\n  const automate = new Automate();\n  const start = automate.addState(); // Nouvel état de départ\n  const end = automate.addState(); // Nouvel état de fin\n\n  // Copier les états et transitions du premier automate\n  automate.states = [...automate1.states, start, end];\n  automate.transitions = [...automate1.transitions];\n\n  // Ajouter des transitions epsilon pour l'opérateur +\n  automate.addTransition(start, automate1.startState, \"ε\");\n  automate.addTransition(automate1.endState, end, \"ε\");\n  automate.addTransition(automate1.endState, automate1.startState, \"ε\"); // Boucle\n\n  // Note : Pas de transition directe de start à end (c'est la différence avec Kleene *)\n\n  // Définir les nouveaux états de départ et de fin\n  automate.setStartState(start);\n  automate.setEndState(end);\n  return automate;\n};\n\n// Fonction pour parser une expression régulière en respectant les priorités et les parenthèses\nconst parseRegex = regex => {\n  const precedence = {\n    \"|\": 1,\n    \".\": 2,\n    \"*\": 3,\n    \"+\": 3\n  };\n  const operators = [];\n  const output = [];\n  const isOperator = char => [\"|\", \".\", \"*\", \"+\"].includes(char);\n  const applyOperator = () => {\n    const operator = operators.pop();\n    if (operator === \".\") {\n      const b = output.pop();\n      const a = output.pop();\n      output.push([\".\", a, b]);\n    } else if (operator === \"|\") {\n      const b = output.pop();\n      const a = output.pop();\n      output.push([\"|\", a, b]);\n    } else if (operator === \"*\") {\n      const a = output.pop();\n      output.push([\"*\", a]);\n    } else if (operator === \"+\") {\n      const a = output.pop();\n      output.push([\"+\", a]);\n    }\n  };\n  let i = 0;\n  while (i < regex.length) {\n    const char = regex[i];\n    if (char === \"(\") {\n      // Trouver la sous-expression entre parenthèses\n      let j = i;\n      let openParentheses = 1;\n      while (openParentheses > 0 && ++j < regex.length) {\n        if (regex[j] === \"(\") openParentheses++;\n        if (regex[j] === \")\") openParentheses--;\n      }\n\n      // Appeler récursivement `parseRegex` sur la sous-expression\n      const subexpression = regex.slice(i + 1, j);\n      output.push(parseRegex(subexpression));\n      i = j; // Avancer jusqu'à la parenthèse fermante\n    } else if (!isOperator(char)) {\n      output.push(char); // Ajouter les symboles au output\n    } else {\n      while (operators.length > 0 && operators[operators.length - 1] !== \"(\" && precedence[operators[operators.length - 1]] >= precedence[char]) {\n        applyOperator();\n      }\n      operators.push(char);\n    }\n    i++;\n  }\n\n  // Appliquer les opérateurs restants\n  while (operators.length > 0) {\n    applyOperator();\n  }\n  return output[0];\n};\n\n// Fonction pour parcourir l'arbre syntaxique et créer l'automate\nconst parseArbre = arbre => {\n  if (typeof arbre === \"string\") {\n    return createBaseAutomate(arbre); // Si c'est un symbole\n  }\n  const [op, ...args] = arbre;\n  switch (op) {\n    case \".\":\n      {\n        // Concaténation\n        let result = parseArbre(args[0]);\n        for (let i = 1; i < args.length; i++) {\n          result = concatenateAutomates(result, parseArbre(args[i]));\n        }\n        return result;\n      }\n    case \"|\":\n      {\n        // Union\n        let result = parseArbre(args[0]);\n        for (let i = 1; i < args.length; i++) {\n          result = unionAutomates(result, parseArbre(args[i]));\n        }\n        return result;\n      }\n    case \"*\":\n      {\n        // Fermeture de Kleene\n        return kleeneAutomate(parseArbre(args[0]));\n      }\n    case \"+\":\n      {\n        // L'opérateur +\n        return plusAutomate(parseArbre(args[0]));\n      }\n    default:\n      throw new Error(`Opérateur non supporté: ${op}`);\n  }\n};\n\n// Fonction pour générer l'automate à partir d'une expression régulière\nconst construireAutomate = regex => {\n  const arbre = parseRegex(regex); // Construire l'arbre syntaxique à partir du regex\n  return parseArbre(arbre); // Construire l'automate à partir de l'arbre syntaxique\n};\n\n// Composant React pour afficher l'automate avec les états initiaux et finaux\nconst AutomateVisualizer = ({\n  automate\n}) => {\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n      children: \"\\xC9tats\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 264,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n      children: automate.states.map(state => /*#__PURE__*/_jsxDEV(\"li\", {\n        children: [state, state === automate.startState && \" (Initial)\", state === automate.endState && \" (Final)\"]\n      }, state, true, {\n        fileName: _jsxFileName,\n        lineNumber: 267,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 265,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"h3\", {\n      children: \"Transitions\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 274,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n      children: automate.transitions.map((trans, idx) => /*#__PURE__*/_jsxDEV(\"li\", {\n        children: [trans.from, \" --(\", trans.symbol, \")--> \", trans.to]\n      }, idx, true, {\n        fileName: _jsxFileName,\n        lineNumber: 277,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 275,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 263,\n    columnNumber: 5\n  }, this);\n};\n\n// Composant principal de l'application\n_c = AutomateVisualizer;\nconst Automata = () => {\n  _s();\n  const [automate, setAutomate] = useState(null);\n  const handleGenerateAutomate = regex => {\n    stateCounter = 0; // Réinitialiser le compteur d'état pour chaque nouveau calcul\n    const automate = construireAutomate(regex);\n    setAutomate(automate);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Automate avec transitions epsilon\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 298,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: () => handleGenerateAutomate(\"(a|r|g)+on\"),\n      children: \"G\\xE9n\\xE9rer l'automate pour \\\"S.(a|r|g)+on\\\"\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 299,\n      columnNumber: 7\n    }, this), automate && /*#__PURE__*/_jsxDEV(AutomateVisualizer, {\n      automate: automate\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 302,\n      columnNumber: 20\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 297,\n    columnNumber: 5\n  }, this);\n};\n_s(Automata, \"ERhXFV3aUn5F6JwVd0afoubpN58=\");\n_c2 = Automata;\nexport default Automata;\nvar _c, _c2;\n$RefreshReg$(_c, \"AutomateVisualizer\");\n$RefreshReg$(_c2, \"Automata\");","map":{"version":3,"names":["React","useState","jsxDEV","_jsxDEV","stateCounter","Automate","constructor","states","transitions","startState","endState","addState","newState","push","addTransition","from","to","symbol","setStartState","state","setEndState","getAutomate","createBaseAutomate","automate","start","end","concatenateAutomates","automate1","automate2","unionAutomates","kleeneAutomate","plusAutomate","parseRegex","regex","precedence","operators","output","isOperator","char","includes","applyOperator","operator","pop","b","a","i","length","j","openParentheses","subexpression","slice","parseArbre","arbre","op","args","result","Error","construireAutomate","AutomateVisualizer","children","fileName","_jsxFileName","lineNumber","columnNumber","map","trans","idx","_c","Automata","_s","setAutomate","handleGenerateAutomate","onClick","_c2","$RefreshReg$"],"sources":["C:/Users/Musha/Desktop/DAAR/projet/projet1/src/app/automate.js"],"sourcesContent":["import React, { useState } from \"react\";\r\n\r\n// Compteur d'état global pour assurer des identifiants uniques\r\nlet stateCounter = 0;\r\n\r\n// Classe Automate pour stocker les états et transitions\r\nclass Automate {\r\n  constructor() {\r\n    this.states = [];\r\n    this.transitions = [];\r\n    this.startState = null;\r\n    this.endState = null;\r\n  }\r\n\r\n  // Fonction pour ajouter un état avec un identifiant unique\r\n  addState() {\r\n    const newState = stateCounter++;\r\n    this.states.push(newState);\r\n    return newState;\r\n  }\r\n\r\n  addTransition(from, to, symbol) {\r\n    this.transitions.push({ from, to, symbol });\r\n  }\r\n\r\n  setStartState(state) {\r\n    this.startState = state;\r\n  }\r\n\r\n  setEndState(state) {\r\n    this.endState = state;\r\n  }\r\n\r\n  getAutomate() {\r\n    return {\r\n      states: this.states,\r\n      transitions: this.transitions,\r\n      startState: this.startState,\r\n      endState: this.endState,\r\n    };\r\n  }\r\n}\r\n\r\n// Fonction pour créer un automate pour un symbole\r\nconst createBaseAutomate = (symbol) => {\r\n  const automate = new Automate();\r\n  const start = automate.addState();\r\n  const end = automate.addState();\r\n  automate.addTransition(start, end, symbol);\r\n  automate.setStartState(start);\r\n  automate.setEndState(end);\r\n  return automate;\r\n};\r\n\r\n// Fonction pour concaténer deux automates\r\nconst concatenateAutomates = (automate1, automate2) => {\r\n  const automate = new Automate();\r\n\r\n  // Copier les états et transitions des deux automates\r\n  automate.states = [...automate1.states, ...automate2.states];\r\n  automate.transitions = [...automate1.transitions, ...automate2.transitions];\r\n\r\n  // Ajouter une transition epsilon entre la fin du premier automate et le début du second\r\n  automate.addTransition(automate1.endState, automate2.startState, \"ε\");\r\n\r\n  // Définir les nouveaux états de départ et de fin\r\n  automate.setStartState(automate1.startState);\r\n  automate.setEndState(automate2.endState);\r\n\r\n  return automate;\r\n};\r\n\r\n// Fonction pour gérer l'union de deux automates (opérateur |)\r\nconst unionAutomates = (automate1, automate2) => {\r\n  const automate = new Automate();\r\n  const start = automate.addState(); // Nouvel état de départ\r\n  const end = automate.addState(); // Nouvel état de fin\r\n\r\n  // Copier les états et transitions des deux automates\r\n  automate.states = [...automate1.states, ...automate2.states, start, end];\r\n  automate.transitions = [...automate1.transitions, ...automate2.transitions];\r\n\r\n  // Ajouter des transitions epsilon du nouvel état initial vers les deux sous-automates\r\n  automate.addTransition(start, automate1.startState, \"ε\");\r\n  automate.addTransition(start, automate2.startState, \"ε\");\r\n\r\n  // Ajouter des transitions epsilon des états finaux des sous-automates vers le nouvel état final\r\n  automate.addTransition(automate1.endState, end, \"ε\");\r\n  automate.addTransition(automate2.endState, end, \"ε\");\r\n\r\n  // Définir les nouveaux états de départ et de fin\r\n  automate.setStartState(start);\r\n  automate.setEndState(end);\r\n\r\n  return automate;\r\n};\r\n\r\n// Fonction pour gérer la fermeture de Kleene (opérateur *)\r\nconst kleeneAutomate = (automate1) => {\r\n  const automate = new Automate();\r\n  const start = automate.addState(); // Nouvel état de départ\r\n  const end = automate.addState(); // Nouvel état de fin\r\n\r\n  // Copier les états et transitions du premier automate\r\n  automate.states = [...automate1.states, start, end];\r\n  automate.transitions = [...automate1.transitions];\r\n\r\n  // Ajouter des transitions epsilon pour la fermeture de Kleene\r\n  automate.addTransition(start, automate1.startState, \"ε\");\r\n  automate.addTransition(automate1.endState, end, \"ε\");\r\n  automate.addTransition(automate1.endState, automate1.startState, \"ε\"); // Boucle\r\n  automate.addTransition(start, end, \"ε\"); // Transition directe\r\n\r\n  // Définir les nouveaux états de départ et de fin\r\n  automate.setStartState(start);\r\n  automate.setEndState(end);\r\n\r\n  return automate;\r\n};\r\n\r\n// Fonction pour gérer l'opérateur +\r\nconst plusAutomate = (automate1) => {\r\n  const automate = new Automate();\r\n  const start = automate.addState(); // Nouvel état de départ\r\n  const end = automate.addState(); // Nouvel état de fin\r\n\r\n  // Copier les états et transitions du premier automate\r\n  automate.states = [...automate1.states, start, end];\r\n  automate.transitions = [...automate1.transitions];\r\n\r\n  // Ajouter des transitions epsilon pour l'opérateur +\r\n  automate.addTransition(start, automate1.startState, \"ε\");\r\n  automate.addTransition(automate1.endState, end, \"ε\");\r\n  automate.addTransition(automate1.endState, automate1.startState, \"ε\"); // Boucle\r\n\r\n  // Note : Pas de transition directe de start à end (c'est la différence avec Kleene *)\r\n\r\n  // Définir les nouveaux états de départ et de fin\r\n  automate.setStartState(start);\r\n  automate.setEndState(end);\r\n\r\n  return automate;\r\n};\r\n\r\n// Fonction pour parser une expression régulière en respectant les priorités et les parenthèses\r\nconst parseRegex = (regex) => {\r\n  const precedence = { \"|\": 1, \".\": 2, \"*\": 3, \"+\": 3 };\r\n  const operators = [];\r\n  const output = [];\r\n\r\n  const isOperator = (char) => [\"|\", \".\", \"*\", \"+\"].includes(char);\r\n\r\n  const applyOperator = () => {\r\n    const operator = operators.pop();\r\n    if (operator === \".\") {\r\n      const b = output.pop();\r\n      const a = output.pop();\r\n      output.push([\".\", a, b]);\r\n    } else if (operator === \"|\") {\r\n      const b = output.pop();\r\n      const a = output.pop();\r\n      output.push([\"|\", a, b]);\r\n    } else if (operator === \"*\") {\r\n      const a = output.pop();\r\n      output.push([\"*\", a]);\r\n    } else if (operator === \"+\") {\r\n      const a = output.pop();\r\n      output.push([\"+\", a]);\r\n    }\r\n  };\r\n\r\n  let i = 0;\r\n  while (i < regex.length) {\r\n    const char = regex[i];\r\n\r\n    if (char === \"(\") {\r\n      // Trouver la sous-expression entre parenthèses\r\n      let j = i;\r\n      let openParentheses = 1;\r\n      while (openParentheses > 0 && ++j < regex.length) {\r\n        if (regex[j] === \"(\") openParentheses++;\r\n        if (regex[j] === \")\") openParentheses--;\r\n      }\r\n\r\n      // Appeler récursivement `parseRegex` sur la sous-expression\r\n      const subexpression = regex.slice(i + 1, j);\r\n      output.push(parseRegex(subexpression));\r\n      i = j; // Avancer jusqu'à la parenthèse fermante\r\n    } else if (!isOperator(char)) {\r\n      output.push(char); // Ajouter les symboles au output\r\n    } else {\r\n      while (\r\n        operators.length > 0 &&\r\n        operators[operators.length - 1] !== \"(\" &&\r\n        precedence[operators[operators.length - 1]] >= precedence[char]\r\n      ) {\r\n        applyOperator();\r\n      }\r\n      operators.push(char);\r\n    }\r\n    i++;\r\n  }\r\n\r\n  // Appliquer les opérateurs restants\r\n  while (operators.length > 0) {\r\n    applyOperator();\r\n  }\r\n\r\n  return output[0];\r\n};\r\n\r\n// Fonction pour parcourir l'arbre syntaxique et créer l'automate\r\nconst parseArbre = (arbre) => {\r\n  if (typeof arbre === \"string\") {\r\n    return createBaseAutomate(arbre); // Si c'est un symbole\r\n  }\r\n\r\n  const [op, ...args] = arbre;\r\n\r\n  switch (op) {\r\n    case \".\": {\r\n      // Concaténation\r\n      let result = parseArbre(args[0]);\r\n      for (let i = 1; i < args.length; i++) {\r\n        result = concatenateAutomates(result, parseArbre(args[i]));\r\n      }\r\n      return result;\r\n    }\r\n\r\n    case \"|\": {\r\n      // Union\r\n      let result = parseArbre(args[0]);\r\n      for (let i = 1; i < args.length; i++) {\r\n        result = unionAutomates(result, parseArbre(args[i]));\r\n      }\r\n      return result;\r\n    }\r\n\r\n    case \"*\": {\r\n      // Fermeture de Kleene\r\n      return kleeneAutomate(parseArbre(args[0]));\r\n    }\r\n\r\n    case \"+\": {\r\n      // L'opérateur +\r\n      return plusAutomate(parseArbre(args[0]));\r\n    }\r\n\r\n    default:\r\n      throw new Error(`Opérateur non supporté: ${op}`);\r\n  }\r\n};\r\n\r\n// Fonction pour générer l'automate à partir d'une expression régulière\r\nconst construireAutomate = (regex) => {\r\n  const arbre = parseRegex(regex); // Construire l'arbre syntaxique à partir du regex\r\n  return parseArbre(arbre); // Construire l'automate à partir de l'arbre syntaxique\r\n};\r\n\r\n// Composant React pour afficher l'automate avec les états initiaux et finaux\r\nconst AutomateVisualizer = ({ automate }) => {\r\n  return (\r\n    <div>\r\n      <h3>États</h3>\r\n      <ul>\r\n        {automate.states.map((state) => (\r\n          <li key={state}>\r\n            {state}\r\n            {state === automate.startState && \" (Initial)\"}\r\n            {state === automate.endState && \" (Final)\"}\r\n          </li>\r\n        ))}\r\n      </ul>\r\n      <h3>Transitions</h3>\r\n      <ul>\r\n        {automate.transitions.map((trans, idx) => (\r\n          <li key={idx}>\r\n            {trans.from} --({trans.symbol})--> {trans.to}\r\n          </li>\r\n        ))}\r\n      </ul>\r\n    </div>\r\n  );\r\n};\r\n\r\n// Composant principal de l'application\r\nconst Automata = () => {\r\n  const [automate, setAutomate] = useState(null);\r\n\r\n  const handleGenerateAutomate = (regex) => {\r\n    stateCounter = 0; // Réinitialiser le compteur d'état pour chaque nouveau calcul\r\n    const automate = construireAutomate(regex);\r\n    setAutomate(automate);\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <h1>Automate avec transitions epsilon</h1>\r\n      <button onClick={() => handleGenerateAutomate(\"(a|r|g)+on\")}>\r\n        Générer l'automate pour \"S.(a|r|g)+on\"\r\n      </button>\r\n      {automate && <AutomateVisualizer automate={automate} />}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Automata;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}