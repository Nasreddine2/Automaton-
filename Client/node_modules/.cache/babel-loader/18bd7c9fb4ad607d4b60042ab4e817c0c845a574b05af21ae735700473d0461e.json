{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Musha\\\\Desktop\\\\DAAR\\\\projet\\\\projet1\\\\src\\\\app\\\\egrep.js\",\n  _s = $RefreshSig$();\nimport React, { useState } from \"react\";\n\n// Définition des classes d'automates et des fonctions nécessaires\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nclass SyntaxTreeNode {\n  constructor(type, left = null, right = null, char = null) {\n    this.type = type; // \"CONCAT\", \"UNION\", \"STAR\", \"CHAR\"\n    this.left = left;\n    this.right = right;\n    this.char = char;\n  }\n}\nclass NFA {\n  constructor() {\n    this.startState = null;\n    this.acceptStates = new Set();\n    this.transitions = {};\n  }\n  addTransition(from, symbol, to) {\n    if (!this.transitions[from]) {\n      this.transitions[from] = {};\n    }\n    if (!this.transitions[from][symbol]) {\n      this.transitions[from][symbol] = new Set();\n    }\n    this.transitions[from][symbol].add(to);\n  }\n  addAcceptState(state) {\n    this.acceptStates.add(state);\n  }\n}\nclass DFA {\n  constructor() {\n    this.startState = null;\n    this.acceptStates = new Set();\n    this.transitions = {};\n  }\n  addTransition(from, symbol, to) {\n    if (!this.transitions[from]) {\n      this.transitions[from] = {};\n    }\n    this.transitions[from][symbol] = to;\n  }\n  addAcceptState(state) {\n    this.acceptStates.add(state);\n  }\n  test(input) {\n    let currentState = this.startState;\n    for (let char of input) {\n      if (this.transitions[currentState] && this.transitions[currentState][char]) {\n        currentState = this.transitions[currentState][char];\n      } else {\n        return false;\n      }\n    }\n    return this.acceptStates.has(currentState);\n  }\n}\n\n// Fonction pour convertir l'expression régulière en NFA\nfunction regexToNFA(regex) {\n  let stack = [];\n  for (let char of regex) {\n    if (char === \"*\") {\n      const nfa = stack.pop();\n      stack.push(applyStar(nfa));\n    } else if (char === \"|\") {\n      const right = stack.pop();\n      const left = stack.pop();\n      stack.push(applyUnion(left, right));\n    } else if (char === \".\") {\n      const right = stack.pop();\n      const left = stack.pop();\n      stack.push(applyConcat(left, right));\n    } else {\n      stack.push(buildBasicNFA(char));\n    }\n  }\n  return stack.pop();\n}\n\n// Fonction pour construire un NFA basique pour un caractère\nfunction buildBasicNFA(char) {\n  let nfa = new NFA();\n  const startState = Symbol(\"start\");\n  const acceptState = Symbol(\"accept\");\n  nfa.startState = startState;\n  nfa.addAcceptState(acceptState);\n  nfa.addTransition(startState, char, acceptState);\n  return nfa;\n}\n\n// Fonction pour la concaténation\nfunction applyConcat(nfa1, nfa2) {\n  let nfa = new NFA();\n  nfa.startState = nfa1.startState;\n  for (let state of nfa1.acceptStates) {\n    nfa.addTransition(state, \"\", nfa2.startState);\n  }\n  for (let from in nfa1.transitions) {\n    for (let char in nfa1.transitions[from]) {\n      for (let to of nfa1.transitions[from][char]) {\n        nfa.addTransition(from, char, to);\n      }\n    }\n  }\n  for (let from in nfa2.transitions) {\n    for (let char in nfa2.transitions[from]) {\n      for (let to of nfa2.transitions[from][char]) {\n        nfa.addTransition(from, char, to);\n      }\n    }\n  }\n  for (let state of nfa2.acceptStates) {\n    nfa.addAcceptState(state);\n  }\n  return nfa;\n}\n\n// Fonction pour l'union\nfunction applyUnion(nfa1, nfa2) {\n  let nfa = new NFA();\n  const startState = Symbol(\"start\");\n  nfa.startState = startState;\n  nfa.addTransition(startState, \"\", nfa1.startState);\n  nfa.addTransition(startState, \"\", nfa2.startState);\n  for (let from in nfa1.transitions) {\n    for (let char in nfa1.transitions[from]) {\n      for (let to of nfa1.transitions[from][char]) {\n        nfa.addTransition(from, char, to);\n      }\n    }\n  }\n  for (let from in nfa2.transitions) {\n    for (let char in nfa2.transitions[from]) {\n      for (let to of nfa2.transitions[from][char]) {\n        nfa.addTransition(from, char, to);\n      }\n    }\n  }\n  for (let state of nfa1.acceptStates) {\n    nfa.addAcceptState(state);\n  }\n  for (let state of nfa2.acceptStates) {\n    nfa.addAcceptState(state);\n  }\n  return nfa;\n}\n\n// Fonction pour l'étoile\nfunction applyStar(nfa) {\n  let result = new NFA();\n  const startState = Symbol(\"start\");\n  result.startState = startState;\n  result.addAcceptState(startState);\n  result.addTransition(startState, \"\", nfa.startState);\n  for (let from in nfa.transitions) {\n    for (let char in nfa.transitions[from]) {\n      for (let to of nfa.transitions[from][char]) {\n        result.addTransition(from, char, to);\n      }\n    }\n  }\n  for (let state of nfa.acceptStates) {\n    result.addTransition(state, \"\", nfa.startState);\n    result.addAcceptState(state);\n  }\n  return result;\n}\n\n// Fonction pour convertir le NFA en un DFA\nfunction convertNFAToDFA(nfa) {\n  let dfa = new DFA();\n  let queue = [];\n  let dfaStartState = [nfa.startState];\n  queue.push(dfaStartState);\n  dfa.startState = JSON.stringify(dfaStartState);\n  while (queue.length > 0) {\n    let current = queue.shift();\n    let currentDFAState = JSON.stringify(current);\n    let charTransitions = {};\n    current.forEach(nfaState => {\n      if (nfa.transitions[nfaState]) {\n        for (let char in nfa.transitions[nfaState]) {\n          if (!charTransitions[char]) charTransitions[char] = new Set();\n          nfa.transitions[nfaState][char].forEach(toState => {\n            charTransitions[char].add(toState);\n          });\n        }\n      }\n    });\n    for (let char in charTransitions) {\n      let toDFAState = Array.from(charTransitions[char]);\n      let toDFAStateString = JSON.stringify(toDFAState);\n      dfa.addTransition(currentDFAState, char, toDFAStateString);\n      if (!queue.some(state => JSON.stringify(state) === toDFAStateString)) {\n        queue.push(toDFAState);\n      }\n    }\n    current.forEach(state => {\n      if (nfa.acceptStates.has(state)) dfa.addAcceptState(currentDFAState);\n    });\n  }\n  return dfa;\n}\nfunction EgrepClone() {\n  _s();\n  const [fileContent, setFileContent] = useState(\"\");\n  const [regexPattern, setRegexPattern] = useState(\"\");\n  const [searchResults, setSearchResults] = useState([]);\n\n  // Lecture du fichier et stockage du contenu dans le state\n  const handleFileUpload = event => {\n    const file = event.target.files[0];\n    const reader = new FileReader();\n    reader.onload = () => {\n      setFileContent(reader.result);\n    };\n    reader.readAsText(file);\n  };\n\n  // Fonction de recherche utilisant l'automate\n  const handleSearch = () => {\n    if (!regexPattern) return;\n\n    // Construire le NFA à partir du motif\n    const nfa = regexToNFA(regexPattern);\n\n    // Convertir le NFA en DFA\n    const dfa = convertNFAToDFA(nfa);\n    const lines = fileContent.split(\"\\n\"); // Diviser le contenu du fichier par ligne\n    const results = lines.filter(line => dfa.test(line)); // Rechercher les lignes qui correspondent\n    setSearchResults(results);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n      children: \"Clone egrep - Recherche par Motif avec Automate\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 273,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n      type: \"file\",\n      onChange: handleFileUpload,\n      accept: \".txt\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 276,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n      type: \"text\",\n      placeholder: \"Entrez le motif RegEx\",\n      value: regexPattern,\n      onChange: e => setRegexPattern(e.target.value)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 279,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: handleSearch,\n      children: \"Rechercher\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 287,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n        children: \"R\\xE9sultats de la recherche :\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 291,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n        children: searchResults.map((result, index) => /*#__PURE__*/_jsxDEV(\"li\", {\n          children: result\n        }, index, false, {\n          fileName: _jsxFileName,\n          lineNumber: 294,\n          columnNumber: 13\n        }, this))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 292,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 290,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 272,\n    columnNumber: 5\n  }, this);\n}\n_s(EgrepClone, \"tT/M7XI+F9VJF1+TuBThQI0faVI=\");\n_c = EgrepClone;\nexport default EgrepClone;\nvar _c;\n$RefreshReg$(_c, \"EgrepClone\");","map":{"version":3,"names":["React","useState","jsxDEV","_jsxDEV","SyntaxTreeNode","constructor","type","left","right","char","NFA","startState","acceptStates","Set","transitions","addTransition","from","symbol","to","add","addAcceptState","state","DFA","test","input","currentState","has","regexToNFA","regex","stack","nfa","pop","push","applyStar","applyUnion","applyConcat","buildBasicNFA","Symbol","acceptState","nfa1","nfa2","result","convertNFAToDFA","dfa","queue","dfaStartState","JSON","stringify","length","current","shift","currentDFAState","charTransitions","forEach","nfaState","toState","toDFAState","Array","toDFAStateString","some","EgrepClone","_s","fileContent","setFileContent","regexPattern","setRegexPattern","searchResults","setSearchResults","handleFileUpload","event","file","target","files","reader","FileReader","onload","readAsText","handleSearch","lines","split","results","filter","line","children","fileName","_jsxFileName","lineNumber","columnNumber","onChange","accept","placeholder","value","e","onClick","map","index","_c","$RefreshReg$"],"sources":["C:/Users/Musha/Desktop/DAAR/projet/projet1/src/app/egrep.js"],"sourcesContent":["import React, { useState } from \"react\";\r\n\r\n// Définition des classes d'automates et des fonctions nécessaires\r\nclass SyntaxTreeNode {\r\n  constructor(type, left = null, right = null, char = null) {\r\n    this.type = type; // \"CONCAT\", \"UNION\", \"STAR\", \"CHAR\"\r\n    this.left = left;\r\n    this.right = right;\r\n    this.char = char;\r\n  }\r\n}\r\n\r\nclass NFA {\r\n  constructor() {\r\n    this.startState = null;\r\n    this.acceptStates = new Set();\r\n    this.transitions = {};\r\n  }\r\n\r\n  addTransition(from, symbol, to) {\r\n    if (!this.transitions[from]) {\r\n      this.transitions[from] = {};\r\n    }\r\n    if (!this.transitions[from][symbol]) {\r\n      this.transitions[from][symbol] = new Set();\r\n    }\r\n    this.transitions[from][symbol].add(to);\r\n  }\r\n\r\n  addAcceptState(state) {\r\n    this.acceptStates.add(state);\r\n  }\r\n}\r\n\r\nclass DFA {\r\n  constructor() {\r\n    this.startState = null;\r\n    this.acceptStates = new Set();\r\n    this.transitions = {};\r\n  }\r\n\r\n  addTransition(from, symbol, to) {\r\n    if (!this.transitions[from]) {\r\n      this.transitions[from] = {};\r\n    }\r\n    this.transitions[from][symbol] = to;\r\n  }\r\n\r\n  addAcceptState(state) {\r\n    this.acceptStates.add(state);\r\n  }\r\n\r\n  test(input) {\r\n    let currentState = this.startState;\r\n    for (let char of input) {\r\n      if (\r\n        this.transitions[currentState] &&\r\n        this.transitions[currentState][char]\r\n      ) {\r\n        currentState = this.transitions[currentState][char];\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n    return this.acceptStates.has(currentState);\r\n  }\r\n}\r\n\r\n// Fonction pour convertir l'expression régulière en NFA\r\nfunction regexToNFA(regex) {\r\n  let stack = [];\r\n\r\n  for (let char of regex) {\r\n    if (char === \"*\") {\r\n      const nfa = stack.pop();\r\n      stack.push(applyStar(nfa));\r\n    } else if (char === \"|\") {\r\n      const right = stack.pop();\r\n      const left = stack.pop();\r\n      stack.push(applyUnion(left, right));\r\n    } else if (char === \".\") {\r\n      const right = stack.pop();\r\n      const left = stack.pop();\r\n      stack.push(applyConcat(left, right));\r\n    } else {\r\n      stack.push(buildBasicNFA(char));\r\n    }\r\n  }\r\n\r\n  return stack.pop();\r\n}\r\n\r\n// Fonction pour construire un NFA basique pour un caractère\r\nfunction buildBasicNFA(char) {\r\n  let nfa = new NFA();\r\n  const startState = Symbol(\"start\");\r\n  const acceptState = Symbol(\"accept\");\r\n\r\n  nfa.startState = startState;\r\n  nfa.addAcceptState(acceptState);\r\n  nfa.addTransition(startState, char, acceptState);\r\n\r\n  return nfa;\r\n}\r\n\r\n// Fonction pour la concaténation\r\nfunction applyConcat(nfa1, nfa2) {\r\n  let nfa = new NFA();\r\n\r\n  nfa.startState = nfa1.startState;\r\n  for (let state of nfa1.acceptStates) {\r\n    nfa.addTransition(state, \"\", nfa2.startState);\r\n  }\r\n\r\n  for (let from in nfa1.transitions) {\r\n    for (let char in nfa1.transitions[from]) {\r\n      for (let to of nfa1.transitions[from][char]) {\r\n        nfa.addTransition(from, char, to);\r\n      }\r\n    }\r\n  }\r\n\r\n  for (let from in nfa2.transitions) {\r\n    for (let char in nfa2.transitions[from]) {\r\n      for (let to of nfa2.transitions[from][char]) {\r\n        nfa.addTransition(from, char, to);\r\n      }\r\n    }\r\n  }\r\n\r\n  for (let state of nfa2.acceptStates) {\r\n    nfa.addAcceptState(state);\r\n  }\r\n\r\n  return nfa;\r\n}\r\n\r\n// Fonction pour l'union\r\nfunction applyUnion(nfa1, nfa2) {\r\n  let nfa = new NFA();\r\n  const startState = Symbol(\"start\");\r\n\r\n  nfa.startState = startState;\r\n  nfa.addTransition(startState, \"\", nfa1.startState);\r\n  nfa.addTransition(startState, \"\", nfa2.startState);\r\n\r\n  for (let from in nfa1.transitions) {\r\n    for (let char in nfa1.transitions[from]) {\r\n      for (let to of nfa1.transitions[from][char]) {\r\n        nfa.addTransition(from, char, to);\r\n      }\r\n    }\r\n  }\r\n\r\n  for (let from in nfa2.transitions) {\r\n    for (let char in nfa2.transitions[from]) {\r\n      for (let to of nfa2.transitions[from][char]) {\r\n        nfa.addTransition(from, char, to);\r\n      }\r\n    }\r\n  }\r\n\r\n  for (let state of nfa1.acceptStates) {\r\n    nfa.addAcceptState(state);\r\n  }\r\n  for (let state of nfa2.acceptStates) {\r\n    nfa.addAcceptState(state);\r\n  }\r\n\r\n  return nfa;\r\n}\r\n\r\n// Fonction pour l'étoile\r\nfunction applyStar(nfa) {\r\n  let result = new NFA();\r\n  const startState = Symbol(\"start\");\r\n\r\n  result.startState = startState;\r\n  result.addAcceptState(startState);\r\n  result.addTransition(startState, \"\", nfa.startState);\r\n\r\n  for (let from in nfa.transitions) {\r\n    for (let char in nfa.transitions[from]) {\r\n      for (let to of nfa.transitions[from][char]) {\r\n        result.addTransition(from, char, to);\r\n      }\r\n    }\r\n  }\r\n\r\n  for (let state of nfa.acceptStates) {\r\n    result.addTransition(state, \"\", nfa.startState);\r\n    result.addAcceptState(state);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n// Fonction pour convertir le NFA en un DFA\r\nfunction convertNFAToDFA(nfa) {\r\n  let dfa = new DFA();\r\n  let queue = [];\r\n  let dfaStartState = [nfa.startState];\r\n  queue.push(dfaStartState);\r\n  dfa.startState = JSON.stringify(dfaStartState);\r\n\r\n  while (queue.length > 0) {\r\n    let current = queue.shift();\r\n    let currentDFAState = JSON.stringify(current);\r\n\r\n    let charTransitions = {};\r\n    current.forEach((nfaState) => {\r\n      if (nfa.transitions[nfaState]) {\r\n        for (let char in nfa.transitions[nfaState]) {\r\n          if (!charTransitions[char]) charTransitions[char] = new Set();\r\n          nfa.transitions[nfaState][char].forEach((toState) => {\r\n            charTransitions[char].add(toState);\r\n          });\r\n        }\r\n      }\r\n    });\r\n\r\n    for (let char in charTransitions) {\r\n      let toDFAState = Array.from(charTransitions[char]);\r\n      let toDFAStateString = JSON.stringify(toDFAState);\r\n\r\n      dfa.addTransition(currentDFAState, char, toDFAStateString);\r\n\r\n      if (!queue.some((state) => JSON.stringify(state) === toDFAStateString)) {\r\n        queue.push(toDFAState);\r\n      }\r\n    }\r\n\r\n    current.forEach((state) => {\r\n      if (nfa.acceptStates.has(state)) dfa.addAcceptState(currentDFAState);\r\n    });\r\n  }\r\n\r\n  return dfa;\r\n}\r\n\r\nfunction EgrepClone() {\r\n  const [fileContent, setFileContent] = useState(\"\");\r\n  const [regexPattern, setRegexPattern] = useState(\"\");\r\n  const [searchResults, setSearchResults] = useState([]);\r\n\r\n  // Lecture du fichier et stockage du contenu dans le state\r\n  const handleFileUpload = (event) => {\r\n    const file = event.target.files[0];\r\n    const reader = new FileReader();\r\n    reader.onload = () => {\r\n      setFileContent(reader.result);\r\n    };\r\n    reader.readAsText(file);\r\n  };\r\n\r\n  // Fonction de recherche utilisant l'automate\r\n  const handleSearch = () => {\r\n    if (!regexPattern) return;\r\n\r\n    // Construire le NFA à partir du motif\r\n    const nfa = regexToNFA(regexPattern);\r\n\r\n    // Convertir le NFA en DFA\r\n    const dfa = convertNFAToDFA(nfa);\r\n\r\n    const lines = fileContent.split(\"\\n\"); // Diviser le contenu du fichier par ligne\r\n    const results = lines.filter((line) => dfa.test(line)); // Rechercher les lignes qui correspondent\r\n    setSearchResults(results);\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <h2>Clone egrep - Recherche par Motif avec Automate</h2>\r\n\r\n      {/* Téléchargement du fichier */}\r\n      <input type=\"file\" onChange={handleFileUpload} accept=\".txt\" />\r\n\r\n      {/* Saisie du motif RegEx */}\r\n      <input\r\n        type=\"text\"\r\n        placeholder=\"Entrez le motif RegEx\"\r\n        value={regexPattern}\r\n        onChange={(e) => setRegexPattern(e.target.value)}\r\n      />\r\n\r\n      {/* Bouton pour déclencher la recherche */}\r\n      <button onClick={handleSearch}>Rechercher</button>\r\n\r\n      {/* Affichage des résultats */}\r\n      <div>\r\n        <h3>Résultats de la recherche :</h3>\r\n        <ul>\r\n          {searchResults.map((result, index) => (\r\n            <li key={index}>{result}</li>\r\n          ))}\r\n        </ul>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default EgrepClone;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}