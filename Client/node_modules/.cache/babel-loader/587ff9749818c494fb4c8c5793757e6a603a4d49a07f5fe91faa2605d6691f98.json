{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Musha\\\\Desktop\\\\DAAR\\\\projet\\\\projet1\\\\src\\\\app\\\\automate.js\",\n  _s = $RefreshSig$();\nimport React, { useState } from \"react\";\n\n// Compteur d'état global pour assurer des identifiants uniques\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nlet stateCounter = 0;\n\n// Classe Automate pour stocker les états et transitions\nclass Automate {\n  constructor() {\n    this.states = [];\n    this.transitions = [];\n    this.startState = null;\n    this.endStates = new Set(); // Utilisation d'un ensemble pour gérer plusieurs états finaux\n  }\n\n  // Fonction pour ajouter un état avec un identifiant unique\n  addState() {\n    const newState = stateCounter++;\n    this.states.push(newState);\n    return newState;\n  }\n  addTransition(from, to, symbol) {\n    this.transitions.push({\n      from,\n      to,\n      symbol\n    });\n  }\n  setStartState(state) {\n    this.startState = state;\n  }\n  setEndState(state) {\n    this.endStates.add(state); // Ajouter à l'ensemble des états finaux\n  }\n  getAutomate() {\n    return {\n      states: this.states,\n      transitions: this.transitions,\n      startState: this.startState,\n      endStates: this.endStates // Retourner les états finaux sous forme d'ensemble\n    };\n  }\n}\n\n// Fonction pour créer un automate pour un symbole\nconst createBaseAutomate = symbol => {\n  const automate = new Automate();\n  const start = automate.addState();\n  const end = automate.addState();\n  automate.addTransition(start, end, symbol);\n  automate.setStartState(start);\n  automate.setEndState(end);\n  return automate;\n};\n\n// Fonction pour concaténer deux automates\nconst concatenateAutomates = (automate1, automate2) => {\n  const automate = new Automate();\n\n  // Copier les états et transitions des deux automates\n  automate.states = [...automate1.states, ...automate2.states];\n  automate.transitions = [...automate1.transitions, ...automate2.transitions];\n\n  // Ajouter une transition epsilon entre la fin du premier automate et le début du second\n  automate.addTransition(automate1.endStates.values().next().value, automate2.startState, \"ε\");\n\n  // Définir les nouveaux états de départ et de fin\n  automate.setStartState(automate1.startState);\n  automate.setEndState(automate2.endStates.values().next().value);\n  return automate;\n};\n\n// Fonction pour gérer l'union de deux automates (opérateur |)\nconst unionAutomates = (automate1, automate2) => {\n  const automate = new Automate();\n  const start = automate.addState(); // Nouvel état de départ\n  const end = automate.addState(); // Nouvel état de fin\n\n  // Copier les états et transitions des deux automates\n  automate.states = [...automate1.states, ...automate2.states, start, end];\n  automate.transitions = [...automate1.transitions, ...automate2.transitions];\n\n  // Ajouter des transitions epsilon du nouvel état initial vers les deux sous-automates\n  automate.addTransition(start, automate1.startState, \"ε\");\n  automate.addTransition(start, automate2.startState, \"ε\");\n\n  // Ajouter des transitions epsilon des états finaux des sous-automates vers le nouvel état final\n  automate1.endStates.forEach(state => {\n    automate.addTransition(state, end, \"ε\");\n  });\n  automate2.endStates.forEach(state => {\n    automate.addTransition(state, end, \"ε\");\n  });\n\n  // Définir les nouveaux états de départ et de fin\n  automate.setStartState(start);\n  automate.setEndState(end);\n  return automate;\n};\n\n// Fonction pour gérer la fermeture de Kleene (opérateur *)\nconst kleeneAutomate = automate1 => {\n  const automate = new Automate();\n  const start = automate.addState(); // Nouvel état de départ\n  const end = automate.addState(); // Nouvel état de fin\n\n  // Copier les états et transitions du premier automate\n  automate.states = [...automate1.states, start, end];\n  automate.transitions = [...automate1.transitions];\n\n  // Ajouter des transitions epsilon pour la fermeture de Kleene\n  automate.addTransition(start, automate1.startState, \"ε\");\n  automate.addTransition(automate1.endStates.values().next().value, end, \"ε\");\n  automate.addTransition(automate1.endStates.values().next().value, automate1.startState, \"ε\"); // Boucle\n  automate.addTransition(start, end, \"ε\"); // Transition directe\n\n  // Définir les nouveaux états de départ et de fin\n  automate.setStartState(start);\n  automate.setEndState(end);\n  return automate;\n};\n\n// Fonction pour gérer l'opérateur +\nconst plusAutomate = automate1 => {\n  const automate = new Automate();\n  const start = automate.addState(); // Nouvel état de départ\n  const end = automate.addState(); // Nouvel état de fin\n\n  // Copier les états et transitions du premier automate\n  automate.states = [...automate1.states, start, end];\n  automate.transitions = [...automate1.transitions];\n\n  // Ajouter des transitions epsilon pour l'opérateur +\n  automate.addTransition(start, automate1.startState, \"ε\");\n  automate.addTransition(automate1.endStates.values().next().value, end, \"ε\");\n  automate.addTransition(automate1.endStates.values().next().value, automate1.startState, \"ε\"); // Boucle\n\n  // Définir les nouveaux états de départ et de fin\n  automate.setStartState(start);\n  automate.setEndState(end);\n  return automate;\n};\n\n// Fonction pour parser une expression régulière en respectant les priorités et les parenthèses\nconst parseRegex = regex => {\n  const precedence = {\n    \"|\": 1,\n    \".\": 2,\n    \"*\": 3,\n    \"+\": 3\n  };\n  const operators = [];\n  const output = [];\n  const isOperator = char => [\"|\", \".\", \"*\", \"+\"].includes(char);\n  const applyOperator = () => {\n    const operator = operators.pop();\n    if (operator === \".\") {\n      const b = output.pop();\n      const a = output.pop();\n      output.push([\".\", a, b]);\n    } else if (operator === \"|\") {\n      const b = output.pop();\n      const a = output.pop();\n      output.push([\"|\", a, b]);\n    } else if (operator === \"*\") {\n      const a = output.pop();\n      output.push([\"*\", a]);\n    } else if (operator === \"+\") {\n      const a = output.pop();\n      output.push([\"+\", a]);\n    }\n  };\n  let i = 0;\n  while (i < regex.length) {\n    const char = regex[i];\n    if (char === \"(\") {\n      // Trouver la sous-expression entre parenthèses\n      let j = i;\n      let openParentheses = 1;\n      while (openParentheses > 0 && ++j < regex.length) {\n        if (regex[j] === \"(\") openParentheses++;\n        if (regex[j] === \")\") openParentheses--;\n      }\n\n      // Appeler récursivement `parseRegex` sur la sous-expression\n      const subexpression = regex.slice(i + 1, j);\n      output.push(parseRegex(subexpression));\n      i = j; // Avancer jusqu'à la parenthèse fermante\n    } else if (!isOperator(char)) {\n      output.push(char); // Ajouter les symboles au output\n    } else {\n      while (operators.length > 0 && operators[operators.length - 1] !== \"(\" && precedence[operators[operators.length - 1]] >= precedence[char]) {\n        applyOperator();\n      }\n      operators.push(char);\n    }\n    i++;\n  }\n\n  // Appliquer les opérateurs restants\n  while (operators.length > 0) {\n    applyOperator();\n  }\n  return output[0];\n};\n\n// Fonction pour parcourir l'arbre syntaxique et créer l'automate\nconst parseArbre = arbre => {\n  if (typeof arbre === \"string\") {\n    return createBaseAutomate(arbre); // Si c'est un symbole\n  }\n  const [op, ...args] = arbre;\n  switch (op) {\n    case \".\":\n      {\n        // Concaténation\n        let result = parseArbre(args[0]);\n        for (let i = 1; i < args.length; i++) {\n          result = concatenateAutomates(result, parseArbre(args[i]));\n        }\n        return result;\n      }\n    case \"|\":\n      {\n        // Union\n        let result = parseArbre(args[0]);\n        for (let i = 1; i < args.length; i++) {\n          result = unionAutomates(result, parseArbre(args[i]));\n        }\n        return result;\n      }\n    case \"*\":\n      {\n        // Fermeture de Kleene\n        return kleeneAutomate(parseArbre(args[0]));\n      }\n    case \"+\":\n      {\n        // L'opérateur +\n        return plusAutomate(parseArbre(args[0]));\n      }\n    default:\n      throw new Error(`Opérateur non supporté: ${op}`);\n  }\n};\n\n// Fonction pour générer l'automate à partir d'une expression régulière\nconst construireAutomate = regex => {\n  const arbre = parseRegex(regex); // Construire l'arbre syntaxique à partir du regex\n  return parseArbre(arbre); // Construire l'automate à partir de l'arbre syntaxique\n};\n\n// Fonction pour tester si une sous-chaîne est acceptée par l'automate\nconst estAccepte = (automate, chaine, index = 0, etatCourant = automate.startState) => {\n  if (index === chaine.length) {\n    return automate.endStates.has(etatCourant); // Vérifier si l'état courant est un état final\n  }\n  const symbol = chaine[index];\n  let transitions = automate.transitions.filter(t => t.from === etatCourant);\n\n  // Parcourir les transitions epsilon\n  for (let trans of transitions) {\n    if (trans.symbol === \"ε\") {\n      if (estAccepte(automate, chaine, index, trans.to)) {\n        return true;\n      }\n    }\n  }\n\n  // Parcourir les transitions pour le symbole courant\n  for (let trans of transitions) {\n    if (trans.symbol === symbol) {\n      if (estAccepte(automate, chaine, index + 1, trans.to)) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n// Fonction pour compter les occurrences de sous-chaînes acceptées\nconst compterOccurences = (automate, texte) => {\n  const mots = texte.split(\" \");\n  let compte = 0;\n  for (let mot of mots) {\n    if (estAccepte(automate, mot)) {\n      compte++;\n    }\n  }\n  return compte;\n};\n\n// Fonction pour calculer la fermeture epsilon d'un état donné\nconst epsilonClosure = (automate, state) => {\n  const closure = new Set([state]);\n  const stack = [state];\n  while (stack.length > 0) {\n    const currentState = stack.pop();\n    const epsilonTransitions = automate.transitions.filter(t => t.from === currentState && t.symbol === \"ε\");\n    for (const transition of epsilonTransitions) {\n      if (!closure.has(transition.to)) {\n        closure.add(transition.to);\n        stack.push(transition.to);\n      }\n    }\n  }\n  return closure;\n};\n\n// Fonction pour calculer la fermeture epsilon d'un ensemble d'états\nconst epsilonClosureSet = (automate, states) => {\n  let closure = new Set();\n  for (const state of states) {\n    closure = new Set([...closure, ...epsilonClosure(automate, state)]);\n  }\n  return closure;\n};\n\n// Fonction pour calculer la transition d'un ensemble d'états sur un symbole donné\nconst move = (automate, states, symbol) => {\n  const nextStates = new Set();\n  for (const state of states) {\n    const transitions = automate.transitions.filter(t => t.from === state && t.symbol === symbol);\n    for (const transition of transitions) {\n      nextStates.add(transition.to);\n    }\n  }\n  return nextStates;\n};\n\n// Fonction pour déterminiser un automate non déterministe avec epsilon transitions\nconst determinizeAutomate = nfa => {\n  const dfa = new Automate();\n  const alphabet = Array.from(new Set(nfa.transitions.map(t => t.symbol).filter(s => s !== \"ε\")));\n  const initialClosure = epsilonClosure(nfa, nfa.startState);\n  const dfaStatesMap = new Map();\n  dfaStatesMap.set(JSON.stringify([...initialClosure]), dfa.addState());\n  dfa.setStartState(dfaStatesMap.get(JSON.stringify([...initialClosure])));\n  const unprocessedStates = [initialClosure];\n  while (unprocessedStates.length > 0) {\n    const currentSet = unprocessedStates.pop();\n    const currentStateId = dfaStatesMap.get(JSON.stringify([...currentSet]));\n\n    // Vérifier si l'un des états de l'ensemble est un état final du NFA\n    if ([...currentSet].some(state => nfa.endStates.has(state))) {\n      dfa.setEndState(currentStateId); // Marquer cet état comme final dans le DFA\n    }\n    for (const symbol of alphabet) {\n      const nextSet = epsilonClosureSet(nfa, move(nfa, currentSet, symbol));\n      if (nextSet.size === 0) continue; // Ignorer les ensembles vides\n\n      const nextSetKey = JSON.stringify([...nextSet]);\n      if (!dfaStatesMap.has(nextSetKey)) {\n        const newState = dfa.addState();\n        dfaStatesMap.set(nextSetKey, newState);\n        unprocessedStates.push(nextSet);\n      }\n      dfa.addTransition(currentStateId, dfaStatesMap.get(nextSetKey), symbol);\n    }\n  }\n  return dfa;\n};\n\n// Fonction pour ajouter un état mort (dead state) à un automate déterministe\nconst addDeadState = automate => {\n  const deadState = automate.addState();\n  const alphabet = Array.from(new Set(automate.transitions.map(t => t.symbol)));\n\n  // Ajouter des transitions vers l'état mort pour chaque symbole si une transition manque\n  automate.states.forEach(state => {\n    alphabet.forEach(symbol => {\n      const hasTransition = automate.transitions.some(t => t.from === state && t.symbol === symbol);\n      if (!hasTransition) {\n        automate.addTransition(state, deadState, symbol);\n      }\n    });\n  });\n\n  // L'état mort se boucle sur lui-même pour chaque symbole\n  alphabet.forEach(symbol => {\n    automate.addTransition(deadState, deadState, symbol);\n  });\n  return deadState;\n};\n\n// Fonction pour minimiser un automate déterministe\nconst minimizeDFA = dfa => {\n  const deadState = addDeadState(dfa); // Ajouter un état mort\n\n  // Étape 1 : Séparer les états en deux groupes (états acceptants et non acceptants)\n  let partitions = [new Set(dfa.states.filter(state => dfa.endStates.has(state))),\n  // États acceptants\n  new Set(dfa.states.filter(state => !dfa.endStates.has(state))) // États non acceptants\n  ];\n  const alphabet = Array.from(new Set(dfa.transitions.map(t => t.symbol)));\n  let hasChanged = true;\n\n  // Étape 2 : Raffinement des partitions\n  while (hasChanged) {\n    hasChanged = false;\n    const newPartitions = [];\n    partitions.forEach(partition => {\n      const partitionMap = new Map(); // Map pour classer les états en sous-partitions\n\n      partition.forEach(state => {\n        // Construire un \"profil\" des transitions depuis l'état actuel\n        const profile = alphabet.map(symbol => {\n          const transition = dfa.transitions.find(t => t.from === state && t.symbol === symbol);\n          return transition ? [...partitions].findIndex(p => p.has(transition.to)) : -1;\n        }).join(\",\");\n\n        // Ajouter l'état à la sous-partition correspondante\n        if (!partitionMap.has(profile)) {\n          partitionMap.set(profile, new Set());\n        }\n        partitionMap.get(profile).add(state);\n      });\n\n      // Ajouter les nouvelles sous-partitions\n      partitionMap.forEach(subPartition => {\n        newPartitions.push(subPartition);\n      });\n      if (partitionMap.size > 1) {\n        hasChanged = true; // Si on a divisé une partition, continuer\n      }\n    });\n    partitions = newPartitions;\n  }\n\n  // Étape 3 : Fusionner les états équivalents et créer le DFA minimisé\n  const minimizedDFA = new Automate();\n  const stateMap = new Map(); // Map pour suivre les états fusionnés\n\n  partitions.forEach(partition => {\n    const representative = minimizedDFA.addState(); // Représentant de la partition\n    partition.forEach(state => {\n      stateMap.set(state, representative); // Associer l'état à son représentant\n    });\n  });\n\n  // Ajouter les transitions dans le DFA minimisé\n  dfa.transitions.forEach(({\n    from,\n    to,\n    symbol\n  }) => {\n    const newFrom = stateMap.get(from);\n    const newTo = stateMap.get(to);\n    if (!minimizedDFA.transitions.some(t => t.from === newFrom && t.to === newTo && t.symbol === symbol)) {\n      minimizedDFA.addTransition(newFrom, newTo, symbol);\n    }\n  });\n\n  // Définir l'état initial et les états finaux dans le DFA minimisé\n  minimizedDFA.setStartState(stateMap.get(dfa.startState));\n  dfa.endStates.forEach(endState => {\n    minimizedDFA.setEndState(stateMap.get(endState));\n  });\n  return minimizedDFA;\n};\n\n// Composant React pour afficher l'automate avec les états initiaux et finaux\nconst AutomateVisualizer = ({\n  automate\n}) => {\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n      children: \"\\xC9tats\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 528,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n      children: automate.states.map(state => /*#__PURE__*/_jsxDEV(\"li\", {\n        children: [state, automate.endStates.has(state) && \" (Final)\", \" \", state === automate.startState && \" (Initial)\"]\n      }, state, true, {\n        fileName: _jsxFileName,\n        lineNumber: 531,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 529,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"h3\", {\n      children: \"Transitions\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 539,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n      children: automate.transitions.map((trans, idx) => /*#__PURE__*/_jsxDEV(\"li\", {\n        children: [trans.from, \" --(\", trans.symbol, \")--> \", trans.to]\n      }, idx, true, {\n        fileName: _jsxFileName,\n        lineNumber: 542,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 540,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 527,\n    columnNumber: 5\n  }, this);\n};\n\n// Composant principal de l'application\n_c = AutomateVisualizer;\nconst Automata = () => {\n  _s();\n  const [automate, setAutomate] = useState(null); // Automate (NFA ou DFA)\n  const [detAutomate, setDetAutomate] = useState(null); // Automate déterminisé (DFA)\n  const [MinAutomate, setMinAutomate] = useState(null); // Automate Min (Min)\n  const [text, setText] = useState(\"\");\n  const [regex, setRegex] = useState(\"\");\n  const [occurrences, setOccurrences] = useState(0);\n\n  // Fonction pour générer l'automate (NFA)\n  const handleGenerateAutomate = () => {\n    stateCounter = 0; // Réinitialiser le compteur d'état pour chaque nouveau calcul\n    const automate = construireAutomate(regex); // Générer l'automate à partir de l'expression régulière\n    setAutomate(automate); // Stocker l'automate NFA\n    setDetAutomate(null); // Réinitialiser l'automate déterminisé (DFA)\n  };\n\n  // Fonction pour déterminiser l'automate (NFA -> DFA)\n  const handleDeterminizeAutomate = () => {\n    if (automate) {\n      const dfa = determinizeAutomate(automate); // Déterminiser l'automate NFA\n      setDetAutomate(dfa); // Stocker l'automate déterminisé (DFA)\n    }\n  };\n\n  // Exemple de fonction pour appeler la minimisation après la déterminisation\n  const handleMinimizeAutomate = () => {\n    if (detAutomate) {\n      const minimizedDFA = minimizeDFA(detAutomate);\n      setDetAutomate(minimizedDFA); // Mettre à jour l'automate déterminisé avec la version minimisée\n    }\n  };\n\n  // Fonction pour compter les occurrences dans le texte (NFA ou DFA)\n  const handleCountOccurrences = () => {\n    if (detAutomate) {\n      // Si l'automate déterminisé existe, on l'utilise\n      const count = compterOccurences(detAutomate, text);\n      setOccurrences(count);\n    } else if (automate) {\n      // Sinon, on utilise l'automate NFA\n      const count = compterOccurences(automate, text);\n      setOccurrences(count);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Automate avec transitions epsilon\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 599,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"label\", {\n        children: [\"Regex:\", /*#__PURE__*/_jsxDEV(\"input\", {\n          value: regex,\n          onChange: e => setRegex(e.target.value)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 603,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 601,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: handleGenerateAutomate,\n        children: \"G\\xE9n\\xE9rer l'automate\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 605,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: handleDeterminizeAutomate,\n        children: \"D\\xE9terminiser l'automate\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 606,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: handleMinimizeAutomate,\n        children: \"Minimiser l'automate\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 609,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 600,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"label\", {\n        children: [\"Texte:\", /*#__PURE__*/_jsxDEV(\"input\", {\n          value: text,\n          onChange: e => setText(e.target.value)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 614,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 612,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: handleCountOccurrences,\n        children: \"Compter les occurrences\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 616,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 611,\n      columnNumber: 7\n    }, this), automate && /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        children: \"Automate (NFA)\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 622,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(AutomateVisualizer, {\n        automate: automate\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 623,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true), detAutomate && /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        children: \"Automate D\\xE9terminis\\xE9 (DFA)\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 628,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(AutomateVisualizer, {\n        automate: detAutomate\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 629,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true), /*#__PURE__*/_jsxDEV(\"h3\", {\n      children: [\"Nombre d'occurrences: \", occurrences]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 632,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 598,\n    columnNumber: 5\n  }, this);\n};\n_s(Automata, \"g9x0D29cAmeCRvJcV/e1ZMnNu60=\");\n_c2 = Automata;\nexport default Automata;\nvar _c, _c2;\n$RefreshReg$(_c, \"AutomateVisualizer\");\n$RefreshReg$(_c2, \"Automata\");","map":{"version":3,"names":["React","useState","jsxDEV","_jsxDEV","Fragment","_Fragment","stateCounter","Automate","constructor","states","transitions","startState","endStates","Set","addState","newState","push","addTransition","from","to","symbol","setStartState","state","setEndState","add","getAutomate","createBaseAutomate","automate","start","end","concatenateAutomates","automate1","automate2","values","next","value","unionAutomates","forEach","kleeneAutomate","plusAutomate","parseRegex","regex","precedence","operators","output","isOperator","char","includes","applyOperator","operator","pop","b","a","i","length","j","openParentheses","subexpression","slice","parseArbre","arbre","op","args","result","Error","construireAutomate","estAccepte","chaine","index","etatCourant","has","filter","t","trans","compterOccurences","texte","mots","split","compte","mot","epsilonClosure","closure","stack","currentState","epsilonTransitions","transition","epsilonClosureSet","move","nextStates","determinizeAutomate","nfa","dfa","alphabet","Array","map","s","initialClosure","dfaStatesMap","Map","set","JSON","stringify","get","unprocessedStates","currentSet","currentStateId","some","nextSet","size","nextSetKey","addDeadState","deadState","hasTransition","minimizeDFA","partitions","hasChanged","newPartitions","partition","partitionMap","profile","find","findIndex","p","join","subPartition","minimizedDFA","stateMap","representative","newFrom","newTo","endState","AutomateVisualizer","children","fileName","_jsxFileName","lineNumber","columnNumber","idx","_c","Automata","_s","setAutomate","detAutomate","setDetAutomate","MinAutomate","setMinAutomate","text","setText","setRegex","occurrences","setOccurrences","handleGenerateAutomate","handleDeterminizeAutomate","handleMinimizeAutomate","handleCountOccurrences","count","onChange","e","target","onClick","_c2","$RefreshReg$"],"sources":["C:/Users/Musha/Desktop/DAAR/projet/projet1/src/app/automate.js"],"sourcesContent":["import React, { useState } from \"react\";\r\n\r\n// Compteur d'état global pour assurer des identifiants uniques\r\nlet stateCounter = 0;\r\n\r\n// Classe Automate pour stocker les états et transitions\r\nclass Automate {\r\n  constructor() {\r\n    this.states = [];\r\n    this.transitions = [];\r\n    this.startState = null;\r\n    this.endStates = new Set(); // Utilisation d'un ensemble pour gérer plusieurs états finaux\r\n  }\r\n\r\n  // Fonction pour ajouter un état avec un identifiant unique\r\n  addState() {\r\n    const newState = stateCounter++;\r\n    this.states.push(newState);\r\n    return newState;\r\n  }\r\n\r\n  addTransition(from, to, symbol) {\r\n    this.transitions.push({ from, to, symbol });\r\n  }\r\n\r\n  setStartState(state) {\r\n    this.startState = state;\r\n  }\r\n\r\n  setEndState(state) {\r\n    this.endStates.add(state); // Ajouter à l'ensemble des états finaux\r\n  }\r\n\r\n  getAutomate() {\r\n    return {\r\n      states: this.states,\r\n      transitions: this.transitions,\r\n      startState: this.startState,\r\n      endStates: this.endStates, // Retourner les états finaux sous forme d'ensemble\r\n    };\r\n  }\r\n}\r\n\r\n// Fonction pour créer un automate pour un symbole\r\nconst createBaseAutomate = (symbol) => {\r\n  const automate = new Automate();\r\n  const start = automate.addState();\r\n  const end = automate.addState();\r\n  automate.addTransition(start, end, symbol);\r\n  automate.setStartState(start);\r\n  automate.setEndState(end);\r\n  return automate;\r\n};\r\n\r\n// Fonction pour concaténer deux automates\r\nconst concatenateAutomates = (automate1, automate2) => {\r\n  const automate = new Automate();\r\n\r\n  // Copier les états et transitions des deux automates\r\n  automate.states = [...automate1.states, ...automate2.states];\r\n  automate.transitions = [...automate1.transitions, ...automate2.transitions];\r\n\r\n  // Ajouter une transition epsilon entre la fin du premier automate et le début du second\r\n  automate.addTransition(\r\n    automate1.endStates.values().next().value,\r\n    automate2.startState,\r\n    \"ε\"\r\n  );\r\n\r\n  // Définir les nouveaux états de départ et de fin\r\n  automate.setStartState(automate1.startState);\r\n  automate.setEndState(automate2.endStates.values().next().value);\r\n\r\n  return automate;\r\n};\r\n\r\n// Fonction pour gérer l'union de deux automates (opérateur |)\r\nconst unionAutomates = (automate1, automate2) => {\r\n  const automate = new Automate();\r\n  const start = automate.addState(); // Nouvel état de départ\r\n  const end = automate.addState(); // Nouvel état de fin\r\n\r\n  // Copier les états et transitions des deux automates\r\n  automate.states = [...automate1.states, ...automate2.states, start, end];\r\n  automate.transitions = [...automate1.transitions, ...automate2.transitions];\r\n\r\n  // Ajouter des transitions epsilon du nouvel état initial vers les deux sous-automates\r\n  automate.addTransition(start, automate1.startState, \"ε\");\r\n  automate.addTransition(start, automate2.startState, \"ε\");\r\n\r\n  // Ajouter des transitions epsilon des états finaux des sous-automates vers le nouvel état final\r\n  automate1.endStates.forEach((state) => {\r\n    automate.addTransition(state, end, \"ε\");\r\n  });\r\n  automate2.endStates.forEach((state) => {\r\n    automate.addTransition(state, end, \"ε\");\r\n  });\r\n\r\n  // Définir les nouveaux états de départ et de fin\r\n  automate.setStartState(start);\r\n  automate.setEndState(end);\r\n\r\n  return automate;\r\n};\r\n\r\n// Fonction pour gérer la fermeture de Kleene (opérateur *)\r\nconst kleeneAutomate = (automate1) => {\r\n  const automate = new Automate();\r\n  const start = automate.addState(); // Nouvel état de départ\r\n  const end = automate.addState(); // Nouvel état de fin\r\n\r\n  // Copier les états et transitions du premier automate\r\n  automate.states = [...automate1.states, start, end];\r\n  automate.transitions = [...automate1.transitions];\r\n\r\n  // Ajouter des transitions epsilon pour la fermeture de Kleene\r\n  automate.addTransition(start, automate1.startState, \"ε\");\r\n  automate.addTransition(automate1.endStates.values().next().value, end, \"ε\");\r\n  automate.addTransition(\r\n    automate1.endStates.values().next().value,\r\n    automate1.startState,\r\n    \"ε\"\r\n  ); // Boucle\r\n  automate.addTransition(start, end, \"ε\"); // Transition directe\r\n\r\n  // Définir les nouveaux états de départ et de fin\r\n  automate.setStartState(start);\r\n  automate.setEndState(end);\r\n\r\n  return automate;\r\n};\r\n\r\n// Fonction pour gérer l'opérateur +\r\nconst plusAutomate = (automate1) => {\r\n  const automate = new Automate();\r\n  const start = automate.addState(); // Nouvel état de départ\r\n  const end = automate.addState(); // Nouvel état de fin\r\n\r\n  // Copier les états et transitions du premier automate\r\n  automate.states = [...automate1.states, start, end];\r\n  automate.transitions = [...automate1.transitions];\r\n\r\n  // Ajouter des transitions epsilon pour l'opérateur +\r\n  automate.addTransition(start, automate1.startState, \"ε\");\r\n  automate.addTransition(automate1.endStates.values().next().value, end, \"ε\");\r\n  automate.addTransition(\r\n    automate1.endStates.values().next().value,\r\n    automate1.startState,\r\n    \"ε\"\r\n  ); // Boucle\r\n\r\n  // Définir les nouveaux états de départ et de fin\r\n  automate.setStartState(start);\r\n  automate.setEndState(end);\r\n\r\n  return automate;\r\n};\r\n\r\n// Fonction pour parser une expression régulière en respectant les priorités et les parenthèses\r\nconst parseRegex = (regex) => {\r\n  const precedence = { \"|\": 1, \".\": 2, \"*\": 3, \"+\": 3 };\r\n  const operators = [];\r\n  const output = [];\r\n\r\n  const isOperator = (char) => [\"|\", \".\", \"*\", \"+\"].includes(char);\r\n\r\n  const applyOperator = () => {\r\n    const operator = operators.pop();\r\n    if (operator === \".\") {\r\n      const b = output.pop();\r\n      const a = output.pop();\r\n      output.push([\".\", a, b]);\r\n    } else if (operator === \"|\") {\r\n      const b = output.pop();\r\n      const a = output.pop();\r\n      output.push([\"|\", a, b]);\r\n    } else if (operator === \"*\") {\r\n      const a = output.pop();\r\n      output.push([\"*\", a]);\r\n    } else if (operator === \"+\") {\r\n      const a = output.pop();\r\n      output.push([\"+\", a]);\r\n    }\r\n  };\r\n\r\n  let i = 0;\r\n  while (i < regex.length) {\r\n    const char = regex[i];\r\n\r\n    if (char === \"(\") {\r\n      // Trouver la sous-expression entre parenthèses\r\n      let j = i;\r\n      let openParentheses = 1;\r\n      while (openParentheses > 0 && ++j < regex.length) {\r\n        if (regex[j] === \"(\") openParentheses++;\r\n        if (regex[j] === \")\") openParentheses--;\r\n      }\r\n\r\n      // Appeler récursivement `parseRegex` sur la sous-expression\r\n      const subexpression = regex.slice(i + 1, j);\r\n      output.push(parseRegex(subexpression));\r\n      i = j; // Avancer jusqu'à la parenthèse fermante\r\n    } else if (!isOperator(char)) {\r\n      output.push(char); // Ajouter les symboles au output\r\n    } else {\r\n      while (\r\n        operators.length > 0 &&\r\n        operators[operators.length - 1] !== \"(\" &&\r\n        precedence[operators[operators.length - 1]] >= precedence[char]\r\n      ) {\r\n        applyOperator();\r\n      }\r\n      operators.push(char);\r\n    }\r\n    i++;\r\n  }\r\n\r\n  // Appliquer les opérateurs restants\r\n  while (operators.length > 0) {\r\n    applyOperator();\r\n  }\r\n\r\n  return output[0];\r\n};\r\n\r\n// Fonction pour parcourir l'arbre syntaxique et créer l'automate\r\nconst parseArbre = (arbre) => {\r\n  if (typeof arbre === \"string\") {\r\n    return createBaseAutomate(arbre); // Si c'est un symbole\r\n  }\r\n\r\n  const [op, ...args] = arbre;\r\n\r\n  switch (op) {\r\n    case \".\": {\r\n      // Concaténation\r\n      let result = parseArbre(args[0]);\r\n      for (let i = 1; i < args.length; i++) {\r\n        result = concatenateAutomates(result, parseArbre(args[i]));\r\n      }\r\n      return result;\r\n    }\r\n\r\n    case \"|\": {\r\n      // Union\r\n      let result = parseArbre(args[0]);\r\n      for (let i = 1; i < args.length; i++) {\r\n        result = unionAutomates(result, parseArbre(args[i]));\r\n      }\r\n      return result;\r\n    }\r\n\r\n    case \"*\": {\r\n      // Fermeture de Kleene\r\n      return kleeneAutomate(parseArbre(args[0]));\r\n    }\r\n\r\n    case \"+\": {\r\n      // L'opérateur +\r\n      return plusAutomate(parseArbre(args[0]));\r\n    }\r\n\r\n    default:\r\n      throw new Error(`Opérateur non supporté: ${op}`);\r\n  }\r\n};\r\n\r\n// Fonction pour générer l'automate à partir d'une expression régulière\r\nconst construireAutomate = (regex) => {\r\n  const arbre = parseRegex(regex); // Construire l'arbre syntaxique à partir du regex\r\n  return parseArbre(arbre); // Construire l'automate à partir de l'arbre syntaxique\r\n};\r\n\r\n// Fonction pour tester si une sous-chaîne est acceptée par l'automate\r\nconst estAccepte = (\r\n  automate,\r\n  chaine,\r\n  index = 0,\r\n  etatCourant = automate.startState\r\n) => {\r\n  if (index === chaine.length) {\r\n    return automate.endStates.has(etatCourant); // Vérifier si l'état courant est un état final\r\n  }\r\n\r\n  const symbol = chaine[index];\r\n  let transitions = automate.transitions.filter((t) => t.from === etatCourant);\r\n\r\n  // Parcourir les transitions epsilon\r\n  for (let trans of transitions) {\r\n    if (trans.symbol === \"ε\") {\r\n      if (estAccepte(automate, chaine, index, trans.to)) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Parcourir les transitions pour le symbole courant\r\n  for (let trans of transitions) {\r\n    if (trans.symbol === symbol) {\r\n      if (estAccepte(automate, chaine, index + 1, trans.to)) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n// Fonction pour compter les occurrences de sous-chaînes acceptées\r\nconst compterOccurences = (automate, texte) => {\r\n  const mots = texte.split(\" \");\r\n  let compte = 0;\r\n  for (let mot of mots) {\r\n    if (estAccepte(automate, mot)) {\r\n      compte++;\r\n    }\r\n  }\r\n  return compte;\r\n};\r\n\r\n// Fonction pour calculer la fermeture epsilon d'un état donné\r\nconst epsilonClosure = (automate, state) => {\r\n  const closure = new Set([state]);\r\n  const stack = [state];\r\n\r\n  while (stack.length > 0) {\r\n    const currentState = stack.pop();\r\n    const epsilonTransitions = automate.transitions.filter(\r\n      (t) => t.from === currentState && t.symbol === \"ε\"\r\n    );\r\n\r\n    for (const transition of epsilonTransitions) {\r\n      if (!closure.has(transition.to)) {\r\n        closure.add(transition.to);\r\n        stack.push(transition.to);\r\n      }\r\n    }\r\n  }\r\n\r\n  return closure;\r\n};\r\n\r\n// Fonction pour calculer la fermeture epsilon d'un ensemble d'états\r\nconst epsilonClosureSet = (automate, states) => {\r\n  let closure = new Set();\r\n  for (const state of states) {\r\n    closure = new Set([...closure, ...epsilonClosure(automate, state)]);\r\n  }\r\n  return closure;\r\n};\r\n\r\n// Fonction pour calculer la transition d'un ensemble d'états sur un symbole donné\r\nconst move = (automate, states, symbol) => {\r\n  const nextStates = new Set();\r\n  for (const state of states) {\r\n    const transitions = automate.transitions.filter(\r\n      (t) => t.from === state && t.symbol === symbol\r\n    );\r\n    for (const transition of transitions) {\r\n      nextStates.add(transition.to);\r\n    }\r\n  }\r\n  return nextStates;\r\n};\r\n\r\n// Fonction pour déterminiser un automate non déterministe avec epsilon transitions\r\nconst determinizeAutomate = (nfa) => {\r\n  const dfa = new Automate();\r\n  const alphabet = Array.from(\r\n    new Set(nfa.transitions.map((t) => t.symbol).filter((s) => s !== \"ε\"))\r\n  );\r\n\r\n  const initialClosure = epsilonClosure(nfa, nfa.startState);\r\n  const dfaStatesMap = new Map();\r\n  dfaStatesMap.set(JSON.stringify([...initialClosure]), dfa.addState());\r\n  dfa.setStartState(dfaStatesMap.get(JSON.stringify([...initialClosure])));\r\n\r\n  const unprocessedStates = [initialClosure];\r\n\r\n  while (unprocessedStates.length > 0) {\r\n    const currentSet = unprocessedStates.pop();\r\n    const currentStateId = dfaStatesMap.get(JSON.stringify([...currentSet]));\r\n\r\n    // Vérifier si l'un des états de l'ensemble est un état final du NFA\r\n    if ([...currentSet].some((state) => nfa.endStates.has(state))) {\r\n      dfa.setEndState(currentStateId); // Marquer cet état comme final dans le DFA\r\n    }\r\n\r\n    for (const symbol of alphabet) {\r\n      const nextSet = epsilonClosureSet(nfa, move(nfa, currentSet, symbol));\r\n\r\n      if (nextSet.size === 0) continue; // Ignorer les ensembles vides\r\n\r\n      const nextSetKey = JSON.stringify([...nextSet]);\r\n\r\n      if (!dfaStatesMap.has(nextSetKey)) {\r\n        const newState = dfa.addState();\r\n        dfaStatesMap.set(nextSetKey, newState);\r\n        unprocessedStates.push(nextSet);\r\n      }\r\n\r\n      dfa.addTransition(currentStateId, dfaStatesMap.get(nextSetKey), symbol);\r\n    }\r\n  }\r\n\r\n  return dfa;\r\n};\r\n\r\n// Fonction pour ajouter un état mort (dead state) à un automate déterministe\r\nconst addDeadState = (automate) => {\r\n  const deadState = automate.addState();\r\n  const alphabet = Array.from(\r\n    new Set(automate.transitions.map((t) => t.symbol))\r\n  );\r\n\r\n  // Ajouter des transitions vers l'état mort pour chaque symbole si une transition manque\r\n  automate.states.forEach((state) => {\r\n    alphabet.forEach((symbol) => {\r\n      const hasTransition = automate.transitions.some(\r\n        (t) => t.from === state && t.symbol === symbol\r\n      );\r\n      if (!hasTransition) {\r\n        automate.addTransition(state, deadState, symbol);\r\n      }\r\n    });\r\n  });\r\n\r\n  // L'état mort se boucle sur lui-même pour chaque symbole\r\n  alphabet.forEach((symbol) => {\r\n    automate.addTransition(deadState, deadState, symbol);\r\n  });\r\n\r\n  return deadState;\r\n};\r\n\r\n// Fonction pour minimiser un automate déterministe\r\nconst minimizeDFA = (dfa) => {\r\n  const deadState = addDeadState(dfa); // Ajouter un état mort\r\n\r\n  // Étape 1 : Séparer les états en deux groupes (états acceptants et non acceptants)\r\n  let partitions = [\r\n    new Set(dfa.states.filter((state) => dfa.endStates.has(state))), // États acceptants\r\n    new Set(dfa.states.filter((state) => !dfa.endStates.has(state))), // États non acceptants\r\n  ];\r\n\r\n  const alphabet = Array.from(new Set(dfa.transitions.map((t) => t.symbol)));\r\n\r\n  let hasChanged = true;\r\n\r\n  // Étape 2 : Raffinement des partitions\r\n  while (hasChanged) {\r\n    hasChanged = false;\r\n    const newPartitions = [];\r\n\r\n    partitions.forEach((partition) => {\r\n      const partitionMap = new Map(); // Map pour classer les états en sous-partitions\r\n\r\n      partition.forEach((state) => {\r\n        // Construire un \"profil\" des transitions depuis l'état actuel\r\n        const profile = alphabet\r\n          .map((symbol) => {\r\n            const transition = dfa.transitions.find(\r\n              (t) => t.from === state && t.symbol === symbol\r\n            );\r\n            return transition\r\n              ? [...partitions].findIndex((p) => p.has(transition.to))\r\n              : -1;\r\n          })\r\n          .join(\",\");\r\n\r\n        // Ajouter l'état à la sous-partition correspondante\r\n        if (!partitionMap.has(profile)) {\r\n          partitionMap.set(profile, new Set());\r\n        }\r\n        partitionMap.get(profile).add(state);\r\n      });\r\n\r\n      // Ajouter les nouvelles sous-partitions\r\n      partitionMap.forEach((subPartition) => {\r\n        newPartitions.push(subPartition);\r\n      });\r\n\r\n      if (partitionMap.size > 1) {\r\n        hasChanged = true; // Si on a divisé une partition, continuer\r\n      }\r\n    });\r\n\r\n    partitions = newPartitions;\r\n  }\r\n\r\n  // Étape 3 : Fusionner les états équivalents et créer le DFA minimisé\r\n  const minimizedDFA = new Automate();\r\n  const stateMap = new Map(); // Map pour suivre les états fusionnés\r\n\r\n  partitions.forEach((partition) => {\r\n    const representative = minimizedDFA.addState(); // Représentant de la partition\r\n    partition.forEach((state) => {\r\n      stateMap.set(state, representative); // Associer l'état à son représentant\r\n    });\r\n  });\r\n\r\n  // Ajouter les transitions dans le DFA minimisé\r\n  dfa.transitions.forEach(({ from, to, symbol }) => {\r\n    const newFrom = stateMap.get(from);\r\n    const newTo = stateMap.get(to);\r\n    if (\r\n      !minimizedDFA.transitions.some(\r\n        (t) => t.from === newFrom && t.to === newTo && t.symbol === symbol\r\n      )\r\n    ) {\r\n      minimizedDFA.addTransition(newFrom, newTo, symbol);\r\n    }\r\n  });\r\n\r\n  // Définir l'état initial et les états finaux dans le DFA minimisé\r\n  minimizedDFA.setStartState(stateMap.get(dfa.startState));\r\n  dfa.endStates.forEach((endState) => {\r\n    minimizedDFA.setEndState(stateMap.get(endState));\r\n  });\r\n\r\n  return minimizedDFA;\r\n};\r\n\r\n// Composant React pour afficher l'automate avec les états initiaux et finaux\r\nconst AutomateVisualizer = ({ automate }) => {\r\n  return (\r\n    <div>\r\n      <h3>États</h3>\r\n      <ul>\r\n        {automate.states.map((state) => (\r\n          <li key={state}>\r\n            {state}\r\n            {automate.endStates.has(state) && \" (Final)\"}{\" \"}\r\n            {/* Vérifie si l'état est final */}\r\n            {state === automate.startState && \" (Initial)\"}\r\n          </li>\r\n        ))}\r\n      </ul>\r\n      <h3>Transitions</h3>\r\n      <ul>\r\n        {automate.transitions.map((trans, idx) => (\r\n          <li key={idx}>\r\n            {trans.from} --({trans.symbol})--&gt; {trans.to}\r\n          </li>\r\n        ))}\r\n      </ul>\r\n    </div>\r\n  );\r\n};\r\n\r\n// Composant principal de l'application\r\nconst Automata = () => {\r\n  const [automate, setAutomate] = useState(null); // Automate (NFA ou DFA)\r\n  const [detAutomate, setDetAutomate] = useState(null); // Automate déterminisé (DFA)\r\n  const [MinAutomate, setMinAutomate] = useState(null); // Automate Min (Min)\r\n  const [text, setText] = useState(\"\");\r\n  const [regex, setRegex] = useState(\"\");\r\n  const [occurrences, setOccurrences] = useState(0);\r\n\r\n  // Fonction pour générer l'automate (NFA)\r\n  const handleGenerateAutomate = () => {\r\n    stateCounter = 0; // Réinitialiser le compteur d'état pour chaque nouveau calcul\r\n    const automate = construireAutomate(regex); // Générer l'automate à partir de l'expression régulière\r\n    setAutomate(automate); // Stocker l'automate NFA\r\n    setDetAutomate(null); // Réinitialiser l'automate déterminisé (DFA)\r\n  };\r\n\r\n  // Fonction pour déterminiser l'automate (NFA -> DFA)\r\n  const handleDeterminizeAutomate = () => {\r\n    if (automate) {\r\n      const dfa = determinizeAutomate(automate); // Déterminiser l'automate NFA\r\n      setDetAutomate(dfa); // Stocker l'automate déterminisé (DFA)\r\n    }\r\n  };\r\n\r\n  // Exemple de fonction pour appeler la minimisation après la déterminisation\r\n  const handleMinimizeAutomate = () => {\r\n    if (detAutomate) {\r\n      const minimizedDFA = minimizeDFA(detAutomate);\r\n      setDetAutomate(minimizedDFA); // Mettre à jour l'automate déterminisé avec la version minimisée\r\n    }\r\n  };\r\n\r\n  // Fonction pour compter les occurrences dans le texte (NFA ou DFA)\r\n  const handleCountOccurrences = () => {\r\n    if (detAutomate) {\r\n      // Si l'automate déterminisé existe, on l'utilise\r\n      const count = compterOccurences(detAutomate, text);\r\n      setOccurrences(count);\r\n    } else if (automate) {\r\n      // Sinon, on utilise l'automate NFA\r\n      const count = compterOccurences(automate, text);\r\n      setOccurrences(count);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <h1>Automate avec transitions epsilon</h1>\r\n      <div>\r\n        <label>\r\n          Regex:\r\n          <input value={regex} onChange={(e) => setRegex(e.target.value)} />\r\n        </label>\r\n        <button onClick={handleGenerateAutomate}>Générer l'automate</button>\r\n        <button onClick={handleDeterminizeAutomate}>\r\n          Déterminiser l'automate\r\n        </button>\r\n        <button onClick={handleMinimizeAutomate}>Minimiser l'automate</button>\r\n      </div>\r\n      <div>\r\n        <label>\r\n          Texte:\r\n          <input value={text} onChange={(e) => setText(e.target.value)} />\r\n        </label>\r\n        <button onClick={handleCountOccurrences}>\r\n          Compter les occurrences\r\n        </button>\r\n      </div>\r\n      {automate && (\r\n        <>\r\n          <h2>Automate (NFA)</h2>\r\n          <AutomateVisualizer automate={automate} />\r\n        </>\r\n      )}\r\n      {detAutomate && (\r\n        <>\r\n          <h2>Automate Déterminisé (DFA)</h2>\r\n          <AutomateVisualizer automate={detAutomate} />\r\n        </>\r\n      )}\r\n      <h3>Nombre d'occurrences: {occurrences}</h3>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Automata;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}