{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Musha\\\\Desktop\\\\DAAR\\\\projet\\\\projet1\\\\src\\\\app\\\\automate.js\",\n  _s = $RefreshSig$();\nimport React, { useState } from \"react\";\n\n// Utilitaire pour construire les automates à partir de l'arbre syntaxique\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nclass Automate {\n  constructor() {\n    this.states = [];\n    this.transitions = [];\n    this.startState = null;\n    this.endState = null;\n  }\n  addState() {\n    const newState = this.states.length;\n    this.states.push(newState);\n    return newState;\n  }\n  addTransition(from, to, symbol) {\n    this.transitions.push({\n      from,\n      to,\n      symbol\n    });\n  }\n  setStartState(state) {\n    this.startState = state;\n  }\n  setEndState(state) {\n    this.endState = state;\n  }\n  getAutomate() {\n    return {\n      states: this.states,\n      transitions: this.transitions,\n      startState: this.startState,\n      endState: this.endState\n    };\n  }\n}\n\n// Fonction pour analyser l'arbre syntaxique\nconst parseArbre = (arbre, automate) => {\n  if (typeof arbre === \"string\") {\n    // Si c'est une feuille (caractère terminal), on crée un état pour ce caractère\n    const start = automate.addState();\n    const end = automate.addState();\n    automate.addTransition(start, end, arbre);\n    return {\n      start,\n      end\n    };\n  }\n  const [op, ...args] = arbre;\n\n  // Gérer chaque opérateur attendu\n  switch (op) {\n    case \".\":\n      {\n        // Concaténation : On traite chaque enfant et on les connecte par des transitions epsilon\n        let result = parseArbre(args[0], automate);\n        for (let i = 1; i < args.length; i++) {\n          const nextPart = parseArbre(args[i], automate);\n          automate.addTransition(result.end, nextPart.start, \"ε\");\n          result = {\n            start: result.start,\n            end: nextPart.end\n          };\n        }\n        return result;\n      }\n    case \"|\":\n      {\n        // Union : On crée un état initial commun et un état final commun\n        const start = automate.addState();\n        const end = automate.addState();\n        args.forEach(arg => {\n          const subAutomate = parseArbre(arg, automate);\n          automate.addTransition(start, subAutomate.start, \"ε\");\n          automate.addTransition(subAutomate.end, end, \"ε\");\n        });\n        return {\n          start,\n          end\n        };\n      }\n    case \"+\":\n      {\n        // Étoile de Kleene : On traite l'enfant et on boucle sur lui-même avec epsilon transitions\n        const subAutomate = parseArbre(args[0], automate);\n        const start = automate.addState();\n        const end = automate.addState();\n        automate.addTransition(start, subAutomate.start, \"ε\");\n        automate.addTransition(subAutomate.end, end, \"ε\");\n        automate.addTransition(subAutomate.end, subAutomate.start, \"ε\");\n        automate.addTransition(start, end, \"ε\");\n        return {\n          start,\n          end\n        };\n      }\n    default:\n      // Si on rencontre un opérateur non supporté\n      console.error(`Opérateur non supporté: ${op}`);\n      throw new Error(`Opérateur non supporté: ${op}`);\n  }\n};\n\n// Fonction qui construit un automate à partir de l'arbre syntaxique\nconst construireAutomate = arbre => {\n  try {\n    const automate = new Automate();\n    const {\n      start,\n      end\n    } = parseArbre(arbre, automate);\n    automate.setStartState(start);\n    automate.setEndState(end);\n    return automate.getAutomate();\n  } catch (error) {\n    console.error(\"Erreur lors de la génération de l'automate:\", error);\n    return null;\n  }\n};\n\n// Composant React pour afficher l'automate\nconst AutomateVisualizer = ({\n  automate\n}) => {\n  if (!automate) return /*#__PURE__*/_jsxDEV(\"p\", {\n    children: \"Erreur lors de la g\\xE9n\\xE9ration de l'automate.\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 116,\n    columnNumber: 25\n  }, this);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n      children: \"\\xC9tats\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 120,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n      children: automate.states.map(state => /*#__PURE__*/_jsxDEV(\"li\", {\n        children: [\"\\xC9tat \", state]\n      }, state, true, {\n        fileName: _jsxFileName,\n        lineNumber: 123,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 121,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"h3\", {\n      children: \"Transitions\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 126,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n      children: automate.transitions.map((trans, idx) => /*#__PURE__*/_jsxDEV(\"li\", {\n        children: [trans.from, \" --(\", trans.symbol, \")--> \", trans.to]\n      }, idx, true, {\n        fileName: _jsxFileName,\n        lineNumber: 129,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 127,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"h3\", {\n      children: \"\\xC9tat de d\\xE9part\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 134,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      children: automate.startState\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 135,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"h3\", {\n      children: \"\\xC9tat de fin\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 136,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      children: automate.endState\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 137,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 119,\n    columnNumber: 5\n  }, this);\n};\n\n// Exemple de syntaxe d'arbre pour 'S(a|g|r)+on'\n_c = AutomateVisualizer;\nconst arbreExemple1 = [\".\", [\"S\"], [\"+\", [\"|\", [\"a\"], [\"g\"], [\"r\"]]], [\"o\"], [\"n\"]];\n// Exemple de syntaxe d'arbre pour 'a|(b.c)'\nconst arbreExemple2 = [\"|\", [\"a\"], [\".\", [\"b\"], [\"c\"]]];\nconst Automata = () => {\n  _s();\n  const [automate, setAutomate] = useState(null);\n  const handleGenerateAutomate = arbre => {\n    const automate = construireAutomate(arbre);\n    setAutomate(automate);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Automate avec epsilon transitions\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 163,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: () => handleGenerateAutomate(arbreExemple1),\n      children: \"G\\xE9n\\xE9rer l'automate pour \\\"S(a|g|r)+on\\\"\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 164,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: () => handleGenerateAutomate(arbreExemple2),\n      children: \"G\\xE9n\\xE9rer l'automate pour \\\"a|(b.c)\\\"\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 167,\n      columnNumber: 7\n    }, this), automate && /*#__PURE__*/_jsxDEV(AutomateVisualizer, {\n      automate: automate\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 170,\n      columnNumber: 20\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 162,\n    columnNumber: 5\n  }, this);\n};\n_s(Automata, \"ERhXFV3aUn5F6JwVd0afoubpN58=\");\n_c2 = Automata;\nexport default Automata;\nvar _c, _c2;\n$RefreshReg$(_c, \"AutomateVisualizer\");\n$RefreshReg$(_c2, \"Automata\");","map":{"version":3,"names":["React","useState","jsxDEV","_jsxDEV","Automate","constructor","states","transitions","startState","endState","addState","newState","length","push","addTransition","from","to","symbol","setStartState","state","setEndState","getAutomate","parseArbre","arbre","automate","start","end","op","args","result","i","nextPart","forEach","arg","subAutomate","console","error","Error","construireAutomate","AutomateVisualizer","children","fileName","_jsxFileName","lineNumber","columnNumber","map","trans","idx","_c","arbreExemple1","arbreExemple2","Automata","_s","setAutomate","handleGenerateAutomate","onClick","_c2","$RefreshReg$"],"sources":["C:/Users/Musha/Desktop/DAAR/projet/projet1/src/app/automate.js"],"sourcesContent":["import React, { useState } from \"react\";\r\n\r\n// Utilitaire pour construire les automates à partir de l'arbre syntaxique\r\nclass Automate {\r\n  constructor() {\r\n    this.states = [];\r\n    this.transitions = [];\r\n    this.startState = null;\r\n    this.endState = null;\r\n  }\r\n\r\n  addState() {\r\n    const newState = this.states.length;\r\n    this.states.push(newState);\r\n    return newState;\r\n  }\r\n\r\n  addTransition(from, to, symbol) {\r\n    this.transitions.push({ from, to, symbol });\r\n  }\r\n\r\n  setStartState(state) {\r\n    this.startState = state;\r\n  }\r\n\r\n  setEndState(state) {\r\n    this.endState = state;\r\n  }\r\n\r\n  getAutomate() {\r\n    return {\r\n      states: this.states,\r\n      transitions: this.transitions,\r\n      startState: this.startState,\r\n      endState: this.endState,\r\n    };\r\n  }\r\n}\r\n\r\n// Fonction pour analyser l'arbre syntaxique\r\nconst parseArbre = (arbre, automate) => {\r\n  if (typeof arbre === \"string\") {\r\n    // Si c'est une feuille (caractère terminal), on crée un état pour ce caractère\r\n    const start = automate.addState();\r\n    const end = automate.addState();\r\n    automate.addTransition(start, end, arbre);\r\n    return { start, end };\r\n  }\r\n\r\n  const [op, ...args] = arbre;\r\n\r\n  // Gérer chaque opérateur attendu\r\n  switch (op) {\r\n    case \".\": {\r\n      // Concaténation : On traite chaque enfant et on les connecte par des transitions epsilon\r\n      let result = parseArbre(args[0], automate);\r\n      for (let i = 1; i < args.length; i++) {\r\n        const nextPart = parseArbre(args[i], automate);\r\n        automate.addTransition(result.end, nextPart.start, \"ε\");\r\n        result = { start: result.start, end: nextPart.end };\r\n      }\r\n      return result;\r\n    }\r\n\r\n    case \"|\": {\r\n      // Union : On crée un état initial commun et un état final commun\r\n      const start = automate.addState();\r\n      const end = automate.addState();\r\n\r\n      args.forEach((arg) => {\r\n        const subAutomate = parseArbre(arg, automate);\r\n        automate.addTransition(start, subAutomate.start, \"ε\");\r\n        automate.addTransition(subAutomate.end, end, \"ε\");\r\n      });\r\n\r\n      return { start, end };\r\n    }\r\n\r\n    case \"+\": {\r\n      // Étoile de Kleene : On traite l'enfant et on boucle sur lui-même avec epsilon transitions\r\n      const subAutomate = parseArbre(args[0], automate);\r\n      const start = automate.addState();\r\n      const end = automate.addState();\r\n\r\n      automate.addTransition(start, subAutomate.start, \"ε\");\r\n      automate.addTransition(subAutomate.end, end, \"ε\");\r\n      automate.addTransition(subAutomate.end, subAutomate.start, \"ε\");\r\n      automate.addTransition(start, end, \"ε\");\r\n\r\n      return { start, end };\r\n    }\r\n\r\n    default:\r\n      // Si on rencontre un opérateur non supporté\r\n      console.error(`Opérateur non supporté: ${op}`);\r\n      throw new Error(`Opérateur non supporté: ${op}`);\r\n  }\r\n};\r\n\r\n// Fonction qui construit un automate à partir de l'arbre syntaxique\r\nconst construireAutomate = (arbre) => {\r\n  try {\r\n    const automate = new Automate();\r\n    const { start, end } = parseArbre(arbre, automate);\r\n    automate.setStartState(start);\r\n    automate.setEndState(end);\r\n    return automate.getAutomate();\r\n  } catch (error) {\r\n    console.error(\"Erreur lors de la génération de l'automate:\", error);\r\n    return null;\r\n  }\r\n};\r\n\r\n// Composant React pour afficher l'automate\r\nconst AutomateVisualizer = ({ automate }) => {\r\n  if (!automate) return <p>Erreur lors de la génération de l'automate.</p>;\r\n\r\n  return (\r\n    <div>\r\n      <h3>États</h3>\r\n      <ul>\r\n        {automate.states.map((state) => (\r\n          <li key={state}>État {state}</li>\r\n        ))}\r\n      </ul>\r\n      <h3>Transitions</h3>\r\n      <ul>\r\n        {automate.transitions.map((trans, idx) => (\r\n          <li key={idx}>\r\n            {trans.from} --({trans.symbol})--> {trans.to}\r\n          </li>\r\n        ))}\r\n      </ul>\r\n      <h3>État de départ</h3>\r\n      <p>{automate.startState}</p>\r\n      <h3>État de fin</h3>\r\n      <p>{automate.endState}</p>\r\n    </div>\r\n  );\r\n};\r\n\r\n// Exemple de syntaxe d'arbre pour 'S(a|g|r)+on'\r\nconst arbreExemple1 = [\r\n  \".\",\r\n  [\"S\"],\r\n  [\"+\", [\"|\", [\"a\"], [\"g\"], [\"r\"]]],\r\n  [\"o\"],\r\n  [\"n\"],\r\n];\r\n// Exemple de syntaxe d'arbre pour 'a|(b.c)'\r\nconst arbreExemple2 = [\"|\", [\"a\"], [\".\", [\"b\"], [\"c\"]]];\r\n\r\nconst Automata = () => {\r\n  const [automate, setAutomate] = useState(null);\r\n\r\n  const handleGenerateAutomate = (arbre) => {\r\n    const automate = construireAutomate(arbre);\r\n    setAutomate(automate);\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <h1>Automate avec epsilon transitions</h1>\r\n      <button onClick={() => handleGenerateAutomate(arbreExemple1)}>\r\n        Générer l'automate pour \"S(a|g|r)+on\"\r\n      </button>\r\n      <button onClick={() => handleGenerateAutomate(arbreExemple2)}>\r\n        Générer l'automate pour \"a|(b.c)\"\r\n      </button>\r\n      {automate && <AutomateVisualizer automate={automate} />}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Automata;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}