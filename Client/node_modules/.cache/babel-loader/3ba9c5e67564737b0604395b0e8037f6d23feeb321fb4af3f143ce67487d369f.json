{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Musha\\\\Desktop\\\\DAAR\\\\projet\\\\projet1\\\\src\\\\app\\\\automate.js\",\n  _s = $RefreshSig$();\nimport React, { useState } from \"react\";\n\n// Utilitaire pour construire les automates à partir de l'arbre syntaxique\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nclass Automate {\n  constructor() {\n    this.states = [];\n    this.transitions = [];\n    this.startState = null;\n    this.endState = null;\n  }\n  addState() {\n    const newState = this.states.length;\n    this.states.push(newState);\n    return newState;\n  }\n  addTransition(from, to, symbol) {\n    this.transitions.push({\n      from,\n      to,\n      symbol\n    });\n  }\n  setStartState(state) {\n    this.startState = state;\n  }\n  setEndState(state) {\n    this.endState = state;\n  }\n  getAutomate() {\n    return {\n      states: this.states,\n      transitions: this.transitions,\n      startState: this.startState,\n      endState: this.endState\n    };\n  }\n}\n\n// Fonction pour analyser l'arbre syntaxique de la forme donnée\nconst parseArbre = (arbre, automate) => {\n  if (typeof arbre === \"string\") {\n    // Si c'est une feuille (caractère terminal), on crée un état pour ce caractère\n    const start = automate.addState();\n    const end = automate.addState();\n    automate.addTransition(start, end, arbre);\n    return {\n      start,\n      end\n    };\n  }\n  const [op, ...args] = arbre;\n  switch (op) {\n    case \".\":\n      {\n        // Concaténation : On traite chaque enfant et on les connecte par des epsilon-transitions\n        let result = parseArbre(args[0], automate);\n        for (let i = 1; i < args.length; i++) {\n          const nextPart = parseArbre(args[i], automate);\n          automate.addTransition(result.end, nextPart.start, \"ε\");\n          result = {\n            start: result.start,\n            end: nextPart.end\n          };\n        }\n        return result;\n      }\n    case \"|\":\n      {\n        // Union : On crée un état initial commun et un état final commun\n        const start = automate.addState();\n        const end = automate.addState();\n        args.forEach(arg => {\n          const subAutomate = parseArbre(arg, automate);\n          automate.addTransition(start, subAutomate.start, \"ε\");\n          automate.addTransition(subAutomate.end, end, \"ε\");\n        });\n        return {\n          start,\n          end\n        };\n      }\n    case \"+\":\n      {\n        // Étoile de Kleene : On traite l'enfant et on boucle sur lui-même avec epsilon transitions\n        const subAutomate = parseArbre(args[0], automate);\n        const start = automate.addState();\n        const end = automate.addState();\n        automate.addTransition(start, subAutomate.start, \"ε\");\n        automate.addTransition(subAutomate.end, end, \"ε\");\n        automate.addTransition(subAutomate.end, subAutomate.start, \"ε\");\n        automate.addTransition(start, end, \"ε\");\n        return {\n          start,\n          end\n        };\n      }\n    default:\n      throw new Error(\"Opérateur non supporté\");\n  }\n};\n\n// Fonction qui construit un automate à partir de l'arbre syntaxique\nconst construireAutomate = arbre => {\n  const automate = new Automate();\n  const {\n    start,\n    end\n  } = parseArbre(arbre, automate);\n  automate.setStartState(start);\n  automate.setEndState(end);\n  return automate.getAutomate();\n};\n\n// Composant React pour afficher l'automate\nconst AutomateVisualizer = ({\n  automate\n}) => {\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n      children: \"\\xC9tats\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 110,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n      children: automate.states.map(state => /*#__PURE__*/_jsxDEV(\"li\", {\n        children: [\"\\xC9tat \", state]\n      }, state, true, {\n        fileName: _jsxFileName,\n        lineNumber: 113,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 111,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"h3\", {\n      children: \"Transitions\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 116,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n      children: automate.transitions.map((trans, idx) => /*#__PURE__*/_jsxDEV(\"li\", {\n        children: [trans.from, \" --(\", trans.symbol, \")--> \", trans.to]\n      }, idx, true, {\n        fileName: _jsxFileName,\n        lineNumber: 119,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 117,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"h3\", {\n      children: \"\\xC9tat de d\\xE9part\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 124,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      children: automate.startState\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 125,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"h3\", {\n      children: \"\\xC9tat de fin\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 126,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      children: automate.endState\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 127,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 109,\n    columnNumber: 5\n  }, this);\n};\n\n// Exemple de syntaxe d'arbre pour 'S(a|g|r)+on'\n_c = AutomateVisualizer;\nconst arbreExemple1 = [\".\", [\"S\"], [\"+\", [\"|\", [\"a\"], [\"g\"], [\"r\"]]], [\"o\"], [\"n\"]];\n// Exemple de syntaxe d'arbre pour 'a|(b.c)'\nconst arbreExemple2 = [\"|\", [\"a\"], [\".\", [\"b\"], [\"c\"]]];\nconst Automata = () => {\n  _s();\n  const [automate, setAutomate] = useState(null);\n  const handleGenerateAutomate = arbre => {\n    const automate = construireAutomate(arbre);\n    setAutomate(automate);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Automate avec epsilon transitions\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 153,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: () => handleGenerateAutomate(arbreExemple1),\n      children: \"G\\xE9n\\xE9rer l'automate pour \\\"S(a|g|r)+on\\\"\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 154,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: () => handleGenerateAutomate(arbreExemple2),\n      children: \"G\\xE9n\\xE9rer l'automate pour \\\"a|(b.c)\\\"\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 157,\n      columnNumber: 7\n    }, this), automate && /*#__PURE__*/_jsxDEV(AutomateVisualizer, {\n      automate: automate\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 160,\n      columnNumber: 20\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 152,\n    columnNumber: 5\n  }, this);\n};\n_s(Automata, \"ERhXFV3aUn5F6JwVd0afoubpN58=\");\n_c2 = Automata;\nexport default Automata;\nvar _c, _c2;\n$RefreshReg$(_c, \"AutomateVisualizer\");\n$RefreshReg$(_c2, \"Automata\");","map":{"version":3,"names":["React","useState","jsxDEV","_jsxDEV","Automate","constructor","states","transitions","startState","endState","addState","newState","length","push","addTransition","from","to","symbol","setStartState","state","setEndState","getAutomate","parseArbre","arbre","automate","start","end","op","args","result","i","nextPart","forEach","arg","subAutomate","Error","construireAutomate","AutomateVisualizer","children","fileName","_jsxFileName","lineNumber","columnNumber","map","trans","idx","_c","arbreExemple1","arbreExemple2","Automata","_s","setAutomate","handleGenerateAutomate","onClick","_c2","$RefreshReg$"],"sources":["C:/Users/Musha/Desktop/DAAR/projet/projet1/src/app/automate.js"],"sourcesContent":["import React, { useState } from \"react\";\r\n\r\n// Utilitaire pour construire les automates à partir de l'arbre syntaxique\r\nclass Automate {\r\n  constructor() {\r\n    this.states = [];\r\n    this.transitions = [];\r\n    this.startState = null;\r\n    this.endState = null;\r\n  }\r\n\r\n  addState() {\r\n    const newState = this.states.length;\r\n    this.states.push(newState);\r\n    return newState;\r\n  }\r\n\r\n  addTransition(from, to, symbol) {\r\n    this.transitions.push({ from, to, symbol });\r\n  }\r\n\r\n  setStartState(state) {\r\n    this.startState = state;\r\n  }\r\n\r\n  setEndState(state) {\r\n    this.endState = state;\r\n  }\r\n\r\n  getAutomate() {\r\n    return {\r\n      states: this.states,\r\n      transitions: this.transitions,\r\n      startState: this.startState,\r\n      endState: this.endState,\r\n    };\r\n  }\r\n}\r\n\r\n// Fonction pour analyser l'arbre syntaxique de la forme donnée\r\nconst parseArbre = (arbre, automate) => {\r\n  if (typeof arbre === \"string\") {\r\n    // Si c'est une feuille (caractère terminal), on crée un état pour ce caractère\r\n    const start = automate.addState();\r\n    const end = automate.addState();\r\n    automate.addTransition(start, end, arbre);\r\n    return { start, end };\r\n  }\r\n\r\n  const [op, ...args] = arbre;\r\n\r\n  switch (op) {\r\n    case \".\": {\r\n      // Concaténation : On traite chaque enfant et on les connecte par des epsilon-transitions\r\n      let result = parseArbre(args[0], automate);\r\n      for (let i = 1; i < args.length; i++) {\r\n        const nextPart = parseArbre(args[i], automate);\r\n        automate.addTransition(result.end, nextPart.start, \"ε\");\r\n        result = { start: result.start, end: nextPart.end };\r\n      }\r\n      return result;\r\n    }\r\n\r\n    case \"|\": {\r\n      // Union : On crée un état initial commun et un état final commun\r\n      const start = automate.addState();\r\n      const end = automate.addState();\r\n\r\n      args.forEach((arg) => {\r\n        const subAutomate = parseArbre(arg, automate);\r\n        automate.addTransition(start, subAutomate.start, \"ε\");\r\n        automate.addTransition(subAutomate.end, end, \"ε\");\r\n      });\r\n\r\n      return { start, end };\r\n    }\r\n\r\n    case \"+\": {\r\n      // Étoile de Kleene : On traite l'enfant et on boucle sur lui-même avec epsilon transitions\r\n      const subAutomate = parseArbre(args[0], automate);\r\n      const start = automate.addState();\r\n      const end = automate.addState();\r\n\r\n      automate.addTransition(start, subAutomate.start, \"ε\");\r\n      automate.addTransition(subAutomate.end, end, \"ε\");\r\n      automate.addTransition(subAutomate.end, subAutomate.start, \"ε\");\r\n      automate.addTransition(start, end, \"ε\");\r\n\r\n      return { start, end };\r\n    }\r\n\r\n    default:\r\n      throw new Error(\"Opérateur non supporté\");\r\n  }\r\n};\r\n\r\n// Fonction qui construit un automate à partir de l'arbre syntaxique\r\nconst construireAutomate = (arbre) => {\r\n  const automate = new Automate();\r\n  const { start, end } = parseArbre(arbre, automate);\r\n  automate.setStartState(start);\r\n  automate.setEndState(end);\r\n  return automate.getAutomate();\r\n};\r\n\r\n// Composant React pour afficher l'automate\r\nconst AutomateVisualizer = ({ automate }) => {\r\n  return (\r\n    <div>\r\n      <h3>États</h3>\r\n      <ul>\r\n        {automate.states.map((state) => (\r\n          <li key={state}>État {state}</li>\r\n        ))}\r\n      </ul>\r\n      <h3>Transitions</h3>\r\n      <ul>\r\n        {automate.transitions.map((trans, idx) => (\r\n          <li key={idx}>\r\n            {trans.from} --({trans.symbol})--> {trans.to}\r\n          </li>\r\n        ))}\r\n      </ul>\r\n      <h3>État de départ</h3>\r\n      <p>{automate.startState}</p>\r\n      <h3>État de fin</h3>\r\n      <p>{automate.endState}</p>\r\n    </div>\r\n  );\r\n};\r\n\r\n// Exemple de syntaxe d'arbre pour 'S(a|g|r)+on'\r\nconst arbreExemple1 = [\r\n  \".\",\r\n  [\"S\"],\r\n  [\"+\", [\"|\", [\"a\"], [\"g\"], [\"r\"]]],\r\n  [\"o\"],\r\n  [\"n\"],\r\n];\r\n// Exemple de syntaxe d'arbre pour 'a|(b.c)'\r\nconst arbreExemple2 = [\"|\", [\"a\"], [\".\", [\"b\"], [\"c\"]]];\r\n\r\nconst Automata = () => {\r\n  const [automate, setAutomate] = useState(null);\r\n\r\n  const handleGenerateAutomate = (arbre) => {\r\n    const automate = construireAutomate(arbre);\r\n    setAutomate(automate);\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <h1>Automate avec epsilon transitions</h1>\r\n      <button onClick={() => handleGenerateAutomate(arbreExemple1)}>\r\n        Générer l'automate pour \"S(a|g|r)+on\"\r\n      </button>\r\n      <button onClick={() => handleGenerateAutomate(arbreExemple2)}>\r\n        Générer l'automate pour \"a|(b.c)\"\r\n      </button>\r\n      {automate && <AutomateVisualizer automate={automate} />}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Automata;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}